Linuxハードウェアの情報を取得する

###############################################################################
Linuxにおけるudev、hald、lsusbなど

Linuxにおけるudevに関するメモ。USB接続とホットプラグについても、少し。

［udevって何？］
udevは動的にデバイスを管理する仕組みで、カーネル2.6からサポートされるようになった。
udevにおいては各種デバイスの取り扱い方を、/etc/udev/rules.d/配下のルールファイル
 に記述している。
 確認してみると、/etc/udev/rules.d/配下には、50-udev-default.rules,40-redhat.rules,
 60-pcmcia.rules,80-drivers.rules,64-device-mapper.rules….など多数のファイルが
存在している。
 先頭の数値が若い順から適用されるようになっているそうだ。

［ホットプラグ対応について］
ホットプラグデバイス接続時において、以前は/sbin/hotplugを実行して認識していたが、
 最近は一般的にudevが使用される。
udevを使用した、システム上でのデバイス認識の流れについて、以下にメモ。

1.デバイス接続
↓
 2.カーネルがデーモンのudevdに通知
↓
 3.udevdが/etc/udevd/配下のスクリプトファイルを実行する。
※先に言及したルールファイルに従って動的にデバイスファイルが生成される。
↓
 4.デバイスに関する情報がhaldに通知され、新規のデバイスの登録が行われる
※haldはシステム上でデバイスのDBを管理しているHALのデーモン。
↓
 5.D-BUSにより名アプリケーションに情報が通知され、デバイスが使用できる
 ようになる。
※D-BUS(Desktop Bus)はデスクトップアプリ間での通信プロトコルらしいので、
サーバとしてのLinuxには関係ないかも…

この辺りの動きはかなり流動的なようである。以前存在した、haldが呼び出す「fstab-sync」
 （/etc/fstabと同期をとるプログラム）はもうなくなったようだし…？
 今後も何かと変化がありそう。

［lsusbについて］
lsusbコマンドでUSBデバイスの情報を確認する。

例
#------------------------------------------------------------------------------
# lsusb
 Bus 001 Device 002: ID 1267:0201 MelCo. , Inc.
 Bus 001 Device 001: ID 0000:0000 <- - ホストコントローラー

lsusbは/proc/bus/usb/devicesから情報を読み込んでいる。
# cat /proc/bus/usb/devices を実行するとなんとなく分かると思う。
#------------------------------------------------------------------------------

lsusb -vは例によって詳細表示。
lsusb -tは、USB階層をツリー形式で表示する。これにより、デバイスマップが理解
しやすくなる、かも？（告白すると、自分は見てもよく分かりません）

参照URL
http://www.gentoo.org/doc/ja/usb-guide.xml

###############################################################################
LinuxでCPUの搭載数を調べる

LinuxマシンでCPUの搭載数を調べるには、以下のコマンドを実行する。

$ cat /proc/cpuinfo | grep processor
 processor : 0
 processor : 1
 processor : 2
 processor : 3

Hyper-Threading（ハイパースレッディング 以下HT）が有効になっているという前提
で言うと、上記のように001まで4つ並んでいたら、物理的なCPUは２つ。
HTによりOS上では仮想的に4つに見えていることになる。

HTがOFFのマシンであれば、表示された数がそのままのCPU数と捉えてよいと思われる。
 以下のように0,1と２つの表示だったら物理CPUは2つ。

processor : 0
 processor : 1

ちなみにHTはIntel社の商標で、乱暴に言うとプロセッサコアの仮想化技術。
 例えば、１つのプロセッサコアを論理的に2つに見せかけることができる。

［HT採用の確認］
HTを採用しているかどうかはを確認するのは、ちょっと一筋縄ではいかないようだ。

例えば $ cat /proc/cpuinfo で physical id,siblings の２つの項目があるかどうかを確認する、
という方法があるらしいのだが、実行結果ではHTがOFFのマシンでもこのふたつの項目は存在した。

それと、$ cat /proc/cpuinfo | grep flags の表示で “ht”というのが存在するか。
これも、”ht” があるからといってHTの機能が有効というわけではなく、あくまでOSとして
HTをサポートしているだけ、ということらしい。

コマンドだけで確認するのにてっとり早いのは、例えば
$ cat /proc/cpuinfo | grep processor の結果で、processor :0,1,2,3と並んでいたら、
それぞれのphysical idを確認してみる。
processor :0,1のphysical idが同一であれば、物理的にひとつのCPUとして
捉えることができる（てっとり早いといっておきながら、なんだか書いててややこしいなぁ….）。

HTが有効で物理cpuが２つ、仮想cpu4つの場合、表示例はこんな感じ。

$ cat /proc/cpuinfo | grep “physical id”
physical id : 0
 physical id : 0
 physical id : 3
 physical id : 3

あとは、該当するマシンのプロセッサナンバーをIntelのサイトで確認すれば、
HTが有効かどうかわかる。プロセッサナンバーを調べるには、以下を実行。

$ cat /proc/cpuinfo | grep “model name”

ただ、プロセッサの種類によって他のページもいろいろあるので環境に合わせてご確認を。
それに、上記のコマンドでもマシンによってはプロセッサナンバーに相当するものが表示
されなかたりするんだよねぇ（泣…って、泣くこともないか）

うーむ、「絶対コレ！」というのはないように思えてきた。
ケースバイケースで、手探りで調査するのがよいのでしょう。

追記：cpuがIntel製である、という前提で書いてマス…

追記2：HT採用かどうか確認できるIntelのサイトのページにリンクを貼っていたのだけど、
リンク切れになっていた…トホー。(2009/07/03)

訪問してくれた方、スミマセン。探したけど同じ内容のページは現在ない様子。

以下は、HTかどうかは確認できないけど、プロセッサー・ナンバーに対応したコア数
なら分かるよ…（名プロセッサモデルの画像リンクをクリック→仕様タブをクリック）
インテルR サーバー向けプロセッサー
http://www.intel.co.jp/jp/products/server/processors/index.htm
###############################################################################
dmidecodeでハードウェアの情報を取得する

dmidecodeについて。
Linuxでdmidecodeコマンドを実行すると、ハードウェアの詳細情報が参照できる。
lessにパイプするか、必要な情報のみgrepするとよい。

 例：機器のシリアルナンバーを調べる

# dmidecode | grep Serial

BIOSのバージョン（リリース日）を調べる

# dmidecode | grep Release

以下の書式でもOK

"dmidecode --type キーワード" 

例えば、メモリの情報を抽出する

# dmidecode --type memory

使用可能キーワードは以下となる

bios
 system
 baseboard
 chassis
 processor
 memory
 connector
 slot 

他に、これ以外の名項目を番号で指定しての実行も可能。
 例えばOn Board DevicesはNo.10に対応しているので、以下のコマンドを実行する。

# dmidecode --type 10

上記のオプションはこちらを参照（English）
自分の場合、現在の所使用する用途は限られているけれど、
 知っておくと便利なコマンドなのでしょうw

###############################################################################
lspciでPCIバスデバイスの情報を確認する

lspciは、PCIバスに接続されているデバイスの情報をリストにして出力するコマンド。
これが、ちょっと掘り下げてみたら結構「深い」ことが分かったので、例によって記録。

lspciの表示結果例は以下のようになる。
#------------------------------------------------------------------------------
# lspci
 00:00.0 Host bridge: Intel Corp. 5000P Chipset Memory Controller Hub (rev b1)
 00:02.0 PCI bridge: Intel Corp. 5000 Seres Chipset PCI Express x4 Port 2(rev b1)
 00:03.0 PCI bridge: Intel Corp. 5000 Seres Chipset PCI Express x4 Port 3(rev b1)
 :
 :
 00:15.0 Host bridge: Intel Corp. 5000 Seres Chipset FBD Registers (rev b1)
 00:16.0 Host bridge: Intel Corp. 5000 Seres Chipset FBD Registers (rev b1)
 :
 :
 02:00.0 PCI bridge: Broadcom: Unknown device 0103(rev c3)
 :
 :
 13:00.0 Ethernet controller: Intel Corp. 82571EB Gigabit Ethernet Controller (rev 06)
 13:00.1 Ethernet controller: Intel Corp. 82571EB Gigabit Ethernet Controller (rev 06)
 :
#------------------------------------------------------------------------------
表示内容は先頭から順に、以下の内容となる（・・・でいいと思うが）。

PCI識別番号（PCI機器に割り当てられている識別番号）
クラス名（デバイスの種類）
ベンダー名
デバイス名（ICチップの型番）

ちなみに先頭の値、”00:15.0″等のPCI識別番号は、左から順に

バス番号、デバイス番号、ファンクション番号

という区分になっている。
 （「バス、スロット、機能」と表現する場合もあるみたいだ）

こちらを参照させてもらったところ、これらのlspciの表示は/proc/bus/pci/配下のカーネルがハードウェアから得た情報を元に、/usr/share/hwdata/pci.ids（ハードウェア情報のDB）と照合し、マッチしたものを整形して出力したもの、なのだそうだ。

/proc/bus/pci/配下、/proc/bus/pci/devices（PCIデバイスの設定レジスタ）の中身を見て
 みると、意味不明な数値の羅列にしか見えないのだが当然ちゃんと意味があって、ここには
 クラスIDやデバイスID、ベンダーIDの情報が記述されている。
2カラム目の前半がベンダーIDで後半がデバイスID、だそうだ。
#------------------------------------------------------------------------------
# cat /proc/bus/pci/devices
 :
 0050 80861229 …. …. ….　←8086がベンダーID、1229がデバイスID
 : 
#------------------------------------------------------------------------------
これを元にpci.idsを確認すると、デバイスIDとベンダーIDに対応した内容が格納されて
 いるのが分かる・・・らしい。
 自分は段々、何がなんだか分からなくなってきたけれど。

でもせっかくなので、このpci.idsの見方のポイントを書いておこう。
 以下の書式に沿って情報が格納されている模様。
#------------------------------------------------------------------------------
# Syntax:
 # vendor 　　vendor_name
　　　　　device 　　　　device_name <- - single tab 　　　　　subvendor 　　　subdevice 　　　subsystem_name <- - two tabs
#------------------------------------------------------------------------------
“vendor”はベンダーID、”device”はデバイスIDに相当すると思われる。
また、表示されるのはほとんど”single tab”の行だけみたいだ。
ちなみにpci.idsファイルに登録がないIDの場合はデバイス名がUnknownと表示されるらしい。
・・・はぁ～、こういう仕組みになっているのですね。

コマンドのオプションを少々説明すると、例によって-vは詳細情報を出力する。
 便利な使い方が、-sオプションで名デバイスを指定すればそのデバイスの詳細のみを確認
できること。

# lspci -s 00:11.0 -v

また、「-d ベンダーID:デバイスID -v」で、指定したベンダーIDとデバイスIDを持つ
 デバイスのみ詳細表示する。以下のように、ベンダーIDのみの指定も可。

# lspci -d 8086: -v

ちなみに-bオプションは「バスから見た表示をする」とのことだけど、出力結果の何が
違うのか分からなかった・・・
あと蛇足ながら、ハードウェアの情報を取得するためのlshwというツールがあることを
発見したので、メモ。
lshw入手先(http://ezix.org/project/wiki/HardwareLiSter)

うぅーむ、lspci、深いですw

###############################################################################
scsi_infoでSCSIデバイスの情報を確認する

scsi_infoコマンドは指定したデバイス名をオープンして、SCSIデバイスの詳細情報を
出力する（SCSI ID、デバイスのモデル名、WWNなど）。
ちなみにscsi_infoコマンドが使用できない環境もあるのだが、詳細は不明。
 以下のようにデバイス名を指定して実行する。

# scsi_info デバイスファイル名

以下はコマンド例（末尾の数字は可変）

# scsi_info /dev/sda 　 <- - SCSIハードディスクを指定 # scsi_info /dev/st0 　　 <- - SCSIテープドライブを指定 # scsi_info /dev/ttyS0 　　 <- - シリアルポートを指定 （シリアルポートの情報は、# setserial /dev/ttyS0でも表示される）

以下、出力結果例。
#------------------------------------------------------------------------------
# scsi_info /dev/sdt
 SCSI_ID=”0,0,0,9″ :VENDOR=”HP” :MODEL=”OPEN-V” FM_REV=”5010″ WWN=”60070e40024e7408″ :LUN=”60070e40024e7400-00008e74000017d5″ 
#------------------------------------------------------------------------------

上記の例は外部ストレージのデバイスファイルを指定していて、ベンダーがHPのケース。
ベンダーがEMCだったら、VENDOR=”EMC” :MODEL=”SYMMETRIX” みたいになる。

ちなみにmanを見ると、ベンダー情報は/proc/scsi/scsiから取得しているらしい。
$ cat /proc/scsi/scsiで、現在SCSI接続されているデバイス情報を確認することができる。

FM_REVは、何だかわかりません。。

WWNは”World Wide Name”の略で、FCスイッチやHBA、ディスクのポート等に固定的に
割り当てられた、64bitsのユニークなアドレスのこと。こちらに詳しい話が。

LUNは”Logical Unit Number” のことかと思われるが？？？
これ以上追求するとまたドツボにハマるので・・・

重箱の隅をつつくようなネタですが、こんなコマンドもあるんだな0、ってことで。
