logrotate（ログローテート）の動作確認

Linuxにおけるlogrotate（ログローテート）の機能についておさらい。
ログローテートが実行される際の流れは、概ね以下のようになる。

cronが主設定ファイルの/etc/cron.daily/logrotateを読む。
/etc/logrotate.conf の読み込みから logrotate が起動される。
また/etc/logrotate.conf はそのディレクティブ “include” により、
/etc/logrotate.d/ 配下にある各ログ個別の設定を読み込む。

※http://www.asahi-net.or.jp/~aa4t-nngk/logrotate.htmlから抜粋

しかし今回は、logrotateの設定をどこにどう書くかという話でなく、
 動作確認や、うまく動作しない時の対処について。
 （confのオプション等には上記サイトに書いてあり、なかなか参考になる）

まずテストから。-dオプションで実行せずにテストする。
 以下は、logrotate.dディレクトリ以下の全てがテストの対象となる。

# logrotate -d /etc/logrotate.conf

個別のスクリプトのみをテストしたいのであれば、”/etc/logrotate.d/個別のスクリプト”
を指定する。

# logrotate -d /etc/logrotate.d/httpd

-dvとして-v オプションもつければ詳細表示してくれる。

-f オプションで強制的に実行する

# logrotate -f /etc/logrotate.conf

正常にログのローテーションが行われているか確認する。
 最後にローテーションされたログファイルの日付を確認するには、
/var/lib/logrotate.statusの中身をみる。

# cat /var/lib/logrotate.status

ローテーションを実際に実行させて確認したい場合、/var/lib/logrotate.statusの日付を
 ローテーションされる周期の日付より前に戻してから/usr/sbin/logrotateを実行してみる。
参考：http://blog.goo.ne.jp/cgeryuji/e/746d27a3d2ec92f751cc78cbc05906f9

ログローテートが機能していないようだ、という時には様々な原因が考えられるが、
 取り急ぎ確認すべき設定ファイルは以下・・・くらいでよいかな。

/etc/logrotate.conf
 /etc/logrotate.d/syslog（他、個別設定ファイル）
/etc/cron.daily/logrotate
 /var/lib/logrotate.status

以前ハマった時に参考にさせてもらったサイトをメモしておく。
logrotateでログファイルがローテーションされない事への対処

しかしさんざん調べたあげく、原因はconfファイルに全角文字が混入していたことであった。
・・・力抜けました。

 次回はログローテートファイルに日付を設定する方法について。

追記
 別件で再度ハマったのでメモを。設定ファイルに何も問題ないことが確認できているのに
 ログローテートが動作しない、ということがあった。
テストしたら（最初にやればよかった）、以下のエラーメッセージが。

error:syslog:1 duplicate log entry for /var/log/messages

ログエントリが重複してる？？
/etc/logrotate.d/配下を覗いてみると、、、syslogのコピーがあった！
 設定変更のためsyslogファイルを編集しようとして、バックアップの意図でコピー
 したのだが、削除してなかったのだ。これを削除したところ、テストでエラー発生せず、
 翌日からローテートされるようになった。うーむ、こんなこともあるんだ・・・
参考：http://isolinear.info/blog/archives/cat16/cat10/

分かってみれば非常につまらないミスではあるが、ひとつ学習したわけだ。
/etc/logrotate.d/に余計なものは置かないように注意、です。

###############################################################################
logratateがうまくいかない時の確認事項

まず、logrotateの設定に問題がないかどうかを確認する方法ですが 

$ /usr/sbin/logrotate -d /etc/logrotate.d/httpd
と、「-d」オプションをつけてローテーションする対象のファイルを指定し実行します。
「-d」オプションが、テストで実行してみる（実際にはローテーションされない）オプションになります。

もちろん、/etc/logrotate.confファイルを指定する事も可能です。
この場合、lorotate.confファイル内で、各個別の設定ファイルが読み込まれるのでlogrotate.dディレクトリ以下の全てがテストの対象となります。
通常であれば、全てをテストする必要は無いかと思いますので、logrotate.d以下の個別の設定ファイルを指定して実行してみればよいでしょう。
次に、設定ファイルには問題が無いのに、ローテーションされない場合についてです。
実際に実行しても何の反応もなく、ログのローテーションも行われない場合は、「-v」オプションをつけてローテーションの様子を確認してみればよいです。

$ /usr/sbin/logrotate -v /etc/logrotate.d/http
considering log /var/log/httpd/access_log
log does not need rotating

などの出力があった場合、ローテーションがされていません。

●1. 前回ローテーションされた日を確認する

先ほどのApacheログファイルの設定ファイル例では、「daily」で実行するように指定しています。
logrotateは、この実行の周期を確認して実行します。
どこで前回実行された日を確認しているかと言うと、/var/lib/logrotate.statusに対象のログファイルと実行された日が記載されています。
実行してみるには、この日付をその周期より前に戻してあげる必要があります。
例えば、「daily」で実行するなら、logrotate.statusファイル内の該当ファイルの日付は昨日より前にセットする必要があります。（「weekly」なら1週間以上前）

●2. 設定ファイル内の「rotate」の項目を確認する

$ /usr/sbin/logrotate -v /etc/logrotate.d/http

のように、個別の設定ファイルを指定して実行した場合、logrotate.confに書いた設定内容が反映されていないので注意が必要です。ですので、先ほど書いた設定ファイルの例で、logrotate.conf内に「rotate」の記載はありますが個別の「http」のファイルには記載がありません。
ですので、「rotate」の設定は有効になっておらずデフォルト値の「0」が採用されます。
「rotate」とは、ローテーションして保管する世代数を表しますが「0」の場合、ローテーションされた瞬間に切り捨てられます。

つまり、対象のログファイルの内容が消されて、新しくファイルが作られるだけ（createを指定した場合）対応として、「rotate」の項目を追加し「0」以外の数値を指定して実行してみてください。

●3. ログファイルのサイズと、設定ファイルの「size」項目の確認

「-v」オプションつきで実行してみた際に
rotating pattern: /var/log/httpd/access_log 1048576 bytes (no old logs will be kept)

のような出力があった場合、対象となるログファイルがローテーションの対象サイズより小さいためローテーションされていない可能性があります。

上記の例の場合、対照のログファイルのサイズが1MB以下であるためローテーションの対象ではないと判断されてしまっています。
これを変更するためには、設定ファイルに「size」の項目を追加して、対象にしたいファイルサイズを指定してあげれば動作します。「0」を指定した場合、ファイルサイズに関係なくローテーションされます。
デフォルトでは、1MBのようです。

※ 全て、RedHatES4 ＋ logrotate-3.7.1-5で確認しました。バージョンの違いによりデフォルト値や挙動が異なってくる
　　可能性があります。また、実行してみる際はテスト環境などでまず行ってみてください。
　　上記の設定の過程でログファイル自体が完全に消失する可能性もあります。

先月頭にRedHatES4のRPMパッケージの更新が大量に出ていて、それを適用させてからlogrotateの挙動がおかしくなりました。（logrotate自体が更新パッケージに含まれていましたし）

具体的には、「postrotate」～「endscript」内が正しく実行されません。

私の環境では、「logrotateでローテーションされるファイル名を変更する 」に書いたローテーション後に日付を入れるスクリプトを書いていますが、この中で

for f in $1; 

の箇所の「$1」に対象のログファイル名が入ってきません。

対象のログファイルは、設定ファイルの先頭の
/var/log/httpd/*_log { 
から取り込まれるはずなのですが、これが取り込まれず変数が空になっているようです。

対処方法として、対象のログを全て記述し、for分もそのように記載します。
/var/log/httpd/*_log {
を、下記のように変更

/var/log/httpd/access_log /var/log/httpd/error_log {
また、
for f in $1;
を、下記のように変更

for f in /var/log/httpd/access_log /var/log/httpd/error_log;

これで何とか動くようになりました。
パッケージ自体のバグなのかな・・・？

###############################################################################
logrotateのログファイル名に日付を設定する

ログローテートの設定において、ログファイル名の末尾を数字ではなく日付にしたい時。
logrotate-3.7.3以降の場合、”dateext”を記述するだけでいいらしい。
なんだ、簡単じゃないか、と思ったが。。

 以下の文言を発見してしまった。
※http://tech.ckme.co.jp/linuxadmin.shtmlより
CentOS 5では、logrotateにバグがあり、dateextやcompressなどのオプションが使えない。

しかしこんなのも発見。
※http://d.hatena.ne.jp/snufkinski/20090520/1242815344より
CentOS 5.3 の logrotate-3.7.4-9 (09-Mar-2009 10:46) では修正されたようです。

うーん、じゃあ大丈夫なのか？？？
 （よく読むと別のバグの話かもしれない・・・）

それからこんな注意点も発見してしまった。
※http://ameblo.jp/itboy/entry-10028063448.htmlより
　　ローテーションした後のファイル名を変更してしまうと、世代数の
　　管理（設定した世代数を超えた場合に、対象のログファイルを削除する）が行えません。
　　（logrotateは、ファイルの後についた数値で世代数を管理しているようなので、
　　その数値がなくなってしまうと、世代が管理できなくなってしまいます）

対処用スクリプトサンプルも上記サイト内にあるので、必要であれば参考にさせて
 もらうとして・・・
まずは”dateext”を試してみて、駄目だったら結局スクリプトで対応か。

/etc/logrotate.d/syslog に記述（postscriptの後）
#--------------------------------------
lastaction
 DATE=`/bin/date +%Y%m%d`
 for logfile in messages secure maillog spooler boot.log cron
 do
 mv /var/log/$logfile.1.gz /var/log/$logfile.${DATE}.gz 2> /dev/null || true
 rm /var/log/$logfile.${DATE} `date -d '3 weeks ago'`.gz 2> /dev/null || true
 done
 endscript
#--------------------------------------
/var/log/以外の個別スクリプトだったらこれだけ加えればいいかな。

#--------------------------------------
lastaction
 DATE=`/bin/date +%Y%m%d`
mv *.1.gz *.${DATE}.gz 　←これはいけてません
endscript
#--------------------------------------

logrotateはバグっていたり、バージョンによる挙動の違いが多々あったりして、
ハマっている人が多い様子。なんだかあれこれと情報が錯綜しているので、
もうやってみないとわからん、という状況だ。
 何か分かったらまた追記しようと思う。

 追記
mvコマンドは複数のファイルに適用できないことを忘れてた。
ログが数種類あるならやはりfor文を利用しなくてはならない。
“dateext”がいけるのかどうかはわからない。
 時間があれば検証したいところだが。


追記（2013/09/08）
 今さらだが、現在dateextオプションが普通に利用できるので上記のスクリプトは不要である。
