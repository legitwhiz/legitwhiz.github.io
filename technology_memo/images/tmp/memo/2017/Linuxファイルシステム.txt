Linuxファイルシステム

###############################################################################
Linuxファイルシステムにおけるスーパーブロックとは？
Linuxファイルシステムについて。
 参考書で何気に見かけた「スーパーブロック」の意味が、分かっているようで分かって
 いなかったのでメモを。

スーパーブロックは、ひと言で言うとファイルシステムの管理情報を記録する領域のこと、
なのだった。

ext2/ext3では記録領域をスーパーブロック、iノードテーブル、データブロックの3種類
に分けて管理する。
スーパーブロックはディスクパーティションごとに1つだけ用意されているため、複数の
 ディスクパーティションをmke2fsコマンドで初期化した場合、それぞれのパーティション
（区画）にスーパーブロックが作成される。

スーパーブロックには以下の情報が記録される。

・パーティション内のデータブロック数
・ブロックサイズ
 ・空きブロック数
・iノード数
・空きiノード数

….ってことダ。
 今回はあっさり済ませておこうw

###############################################################################
Linuxファイルシステムにおけるiノードについて

ファイルシステムの管理領域であるスーパーブロックに、iノード数や空きノード数が格納される。
Linux他、UNIX系OSのファイルシステムにおいてiノードは重要な概念。
ということで、勝手におさらいします。

iノードはLinuxのファイルシステムにおいて、ファイルの属性や管理情報を格納している
管理領域（インデックス）となる。この管理領域はファイルのデータ（中身）とは別に
保存されている。
ファイルのデータはデータブロックに、属性情報はiノードブロックに格納される。

ここでファイル保存時にどちらかの書込みが失敗すると、整合性がとれなくなる。
 整合性のチェックにはfsck、ですね。

iノードブロックに格納される情報は以下となる。

・ファイル種別
・ファイルサイズ
 ・アクセス権
・所有者
・リンク
 ・ディスク上の保存場所（ブロック番号）

使用可能なiノード数はファイルシステム作成時にあらかじめ決定され、後から追加する
 ことはできない。iノードはファイルやディレクトリを作るたびに１つずつ使われて行くため
（ファイルをディスクに保存するたびに、重複しないiノード番号が割当られる）、大量に
 ファイルを作成・保存していくうちにiノードが枯渇してしまう可能性がある。
こうなるとディスクに空き容量があったとしても新規にファイルを保存できなくなるため、
iノードの使用状況にも注意が必要となる。

iノードの使用状況はdf -i コマンドで確認することができる。
また、ls -i コマンドでファイルのiノード番号を確認できる。

ハードリンクを作成すると元ファイルとリンク先ファイルは同じiノードを持っている、
というのは基本中の基本。
 （これに対してシンボリックリンクは、リンク先の情報をiノードではなくパス名、
つまり保存先で保持する仕組みになっている）

…などなど、教科書的なことしか書いていないけど（というかそのまんま）、iノード数
が上限に達して新たにファイルを保存できなくなってしまった、という事例には実際に
遭遇したことがある。

 紆余曲折あったものの、最終的には不要なファイルを徹底的に削除して再起動したらOK、
だったような。
ついついディスクの空き容量だけに注目しがちだけど、iノードの監視も忘れないように、
ってことですね！

 追記：ReiserFS、XFSは動的iノードという仕組みが導入されているため、iノード枯渇
という事象は基本的におきないらしい。


###############################################################################
Linux: mkfsコマンドなど

 新規ファイルシステム作成時のコマンドは、ファイルシステムの種類によりいろいろ。
 混乱しがちなので、ちょっとまとめてみた。

● 例えばext3ファイルシステムを新規に作成するには、以下3通りのコマンドがある。
 （各種オプションは省略）

# mke2fs -j /dev/sda3
 # mkfs -t ext3 /dev/sda3
 # mkfs.ext3 /dev/sda3 

最初のmke2fsは、ext2/ext3ファイルシステムを作成するためのコマンド。
オプションの -j はジャーナリング機能を意味する。
 今更だけど、ext3はext2にジャーナリング機能をプラスしたファイルシステムなので。
 （-jオプションがなければext2でファイルシステムが作成される）
ちなみに、tune2fs -j /dev/sda3は既存のext2デバイスファイルをext3に変換する。

●ReiserFSファイルシステムの場合。
# mkreiserfs /dev/sda3
 # mkfs.reisrfs /dev/sda3
 # mkfs -t reiserfs /dev/sda3

mkfs.reisrfsは、mkreiserfsへのシンボリックリンク、とのこと。

●XFSファイルシステムの場合。
# mkfs.xfs
 # mkfs -t xfs

mkfsコマンドは各種ファイルシステムを作成する際のフロントエンドとなり、上記の
他、vfatやminixにも対応している。
パターンは以下の二通りがあるが、どちらでもよい。

mkfs.各種ファイルシステム
mkfs -t 各種ファイルシステム

やっぱり、こうやって書くと何だかスッキリする。・・・ような気がする。

###############################################################################
ファイルシステムのボリュームラベルとは

ファイルシステムのボリュームラベルとは、/etc/fstabで指定する”LABEL=xxxx”のこと。
 広義にはディスクのパーティションを識別しやすくするため、ユーザが自由につけられる名前。

デバイス名ではなくボリュームラベルで管理することにより、ディスクの追加・削除などで
 デバイス名が変わった際、デバイス名の変化に影響を受けなくて済むようになる。
ちなみに、設定が可能なファイルシステムはext2/ext3となる。

以下、ラベル名を定義する手順をざっくりと。

1. e2label コマンドを以下の書式で実行
e2label [対象パーティション] [ラベル名]
# e2label /dev/sda3 test

2. /etc/fstabにラベル名を記述する
LABEL=test 　　　　/tmp 　　　　　ext3 　　　　defaults 　　　　1 1

3.編集の反映には再マウントかマシン再起動を実施
# mount -o remount /tmp

または
# umount /tmp
 # mount /tmp

または、マシン再起動

ついでに油断すると忘れてしまう、/etc/fstabのフィールドの意味についてメモ。

左から順に…

1.マウントするデバイスファイル名
2.マウントポイント
3.マウントするファイルシステムタイプ
4.マウントオプション

ちなみに、defaultsのオプションに含まれるのは、
async / auto / dev / exec /nouser / rw / suid
…となる（それぞれの意味は、長文にしたくないので今回はパスw）

ここでuserを指定すると、一般ユーザーでもマウントが可能に、usersを
指定するとマウントしたユーザー以外のユーザーでもアンマウントが可能になる。
カンマで区切って複数のマウントオプションを指定することも可能。

5.dumpフラグ
「1」がdumpコマンドによるバックアップ対象となり、「0」だと対象外となる。

6.fsckフラグ
 ブート時にfsckがチェックする順番。
 「1.2..」の順にチェックされ、「0」はチェックされない。
ルートファイルシステムは必ず「１」。 

###############################################################################
ボリュームラベルとデバイス名の関連付け

Linuxマシンにて、定義されたLABEL（ボリュームラベル）とデバイス名の関連を確認
するためのメモ。
LABELの対象のデバイス名を調べるには、findfsコマンドを利用。

# findfs LABEL=/boot
 /dev/sda2

findfsは、ラベルやUUIDからマッチしたデバイス名を見つける コマンド。
 逆に、デバイス名に割り当てられているLABELを確認するには、e2labelまたはblkidを実行。

# e2label /dev/sda2
 /boot

blkidはブロックデバイスの属性を見つけて表示するコマンドで、UUID他の情報も表示する。
さらに詳細な情報を得たい場合は、tune2fs -l かdumpe2fsコマンドを利用する。
 （これ以上書くと本題から外れるので割愛しマス）

UUIDについては、以下の説明が分かりやすい。
http://itpro.nikkeibp.co.jp/article/Keyword/20090206/324330/

上記によると、UUIDは”universally unique identifier”の略で、機器の識別管理をするため
 のユニークなID。最近のLinuxディストリビューションにおいて、ディスクの識別のため
 に併用されるようになったようだ。

###############################################################################
fsckとe2fsckの違いって？

fsckはLinuxファイルシステムの整合性をチェックし、不整合があった場合は修復するコマンド。
 通常使用することはないと思われるが、ノーマルなシャットダウンやリブート以外で
電源がOFFになってしまった時などに利用される。

つまりファイルシステムの整合性が疑われるから、なんだろうけど、そういう意味で言うと、
それ以外でもファイルシステムに何らかの異常が発生した時に利用するってことになる。
どっちにしろ、fsckをしなければいけない時っていうのは「何か」あった時と考えてよい、と思われる。

追記
 「何か」あったときだけではなく、ディスク拡張の時なんかにも普通に利用しますね。。

fsckはシングルユーザーモードで、対象のファイルシステムをアンマウントした状態で実施する。
e2fsckというのもある。やることは一緒。fsckとe2fsckの違いって・・・?

結論から言うと、「fsck、e2fsckどちらで実行しても構わない」ようだ。
ファイルシステムの種別に応じて実行すべきfsckプログラムが選択され、ext2/ext3であれば
e2fsckが実行され、ReiserFSであれば reiserfsckが実行される・・・とのこと。
つまり、fsckがe2fsckやreiserfsckを呼び出す、ってイメージかな。
 （サラッと書いてるけど、実は、”reiserfsck”って今調べた時に初めて知った）

そういえば「fsck は、実際には Linux で利用できるさまざまなファイルシステムチェッカー
(fsck.fstype) への単なるフロントエンドにすぎない。」とmanに書いてあった。
うーむ、なるほど。

追記
 実際に、fsckとe2fsckの両方を実行してみた。

# fsck -t ext3 /dev/sda1　※fsck.ext3でも。
# e2fsck -y /dev/sda1

結果は当然ながら、同じでした。

###############################################################################
LVMとfsck

LVM（論理ボリュームマネージャ）を採用しているファイルシステムでfsckを実行する場合、
fsckをかける対象は以下のデバイスファイルかlvol（論理ボリューム）か、どちらになるか？

/dev/sda 　←デバイスファイル

/dev/VG_NAME/LV_NAME 　←lvol：論理ボリューム

この場合、下のlvolが対象となる。なので、コマンドは以下の通りになる。

# fsck [ option] /dev/VG_NAME/LV_NAME

それだけなんだけど、小さなことのようで、大事なことってあるし。
ついでに、LVM絡みのミニTipsをもうひとつ。
ここでは便宜上、仮のVG（ボリュームグループ）名を「VG_NAME」とかって
書いているが、実際にVGに名前をつける際は最初を”vg_”にするのが基本だとか。

そうすることによって、それが起動時にLVMのファイルシステムであると認識される
ようになっている、らしい。

どこかのサイトで見て「ふ0ん、なるほど」と思ったのだが、正確な出典元は、今と
 なっては不明・・・（汗）
でもこれも大事なことだと思うので、記録しておくのだw

###############################################################################
fsckの"-f"オプションって？

壊れたファイルシステムに修復をかけるためにfsckを実行
する時、”-f”オプションをつけることで、ファイルシステムがclean(クリーン）な場合でも
強制的に修復をかけることが可能になる、そうだ。

すべてをyesと見なす”-y”オプションのみで実行した場合、使用しているファイルシステムのみ
修復をする形となるため、使用していない部分は壊れたままになってしまう可能性がある。

なので、もし fsck -y や e2fsck -y で修復できなかったら 、”-f”オプションもつけて再試行
してみるといいかも？（保証するものではないですけど、もちろん）

“-f”オプションについてはいろんなところで書かれているが、このサイトの説明は
分かりやすかった。

ちなみに、ファイルシステムがclean（クリーン）であるとマークされる、またはクリーン
 フラグが立っている状態というのは、BSDのmanによると以下の通り。

・アンマウントされた時
・読み取り専用でマウントされた時
・fsck が成功裏に実行された時

ふーむ・・・

追記
LPICの教科書にもっと分かりやすい表現があったので、ここにメモ。
ファイルシステムに対して変更が発生すると「dirty」で、ファイルシステムとブロック
 デバイスが同期されていれば「clean」だそうだ。

###############################################################################
tune2fs -lとdumpe2fs

tune2fsコマンドは、ext2/ext3ファイルシステムの各種パラメータを調整する。
dumpe2fsコマンドは、指定したデバイスにおけるファイルシステムの詳細情報を出力する。

あれ、でもtune2fs -lでも詳細情報が出力されるはず。
 何か違うの？と思い両方実行して比べてみたら。

dumpe2fsだと、Journal sizeとブロックグループの情報も表示される、という違いが
 あるようだ。あとは、スーパーブロックの箇所で出力される項目やその値は、全く同じ。
※ちなみにdumpe2fsに-hオプションをつけるとスーパーブロックの情報のみを出力する。

ブロックグループとは何かというと、
 「スーパーブロック、iノードブロック、データブロックを連続するディスク領域にまとめて
 グループ化したもの」

ってことみたいだ。自分、あまりよく分かってないけど・・・
 ともあれ、この仕様によりI/Oの性能が上がるらしい。

 今回はブロックグループの出力欄だけ例を一部抜粋。
 （面倒だからやめるつもりだったのに、つい・・・）

Group 1: (Blocks 8193-16384)　← ブロックグループ内のブロック番号
Backup superblock at 8193, Group descriptors at 8194-8194
　↑ 8193番ブロックは１つ目のバックアップであることを示す
Reserved GDT blocks at 8195-8450
 Block bitmap at 8451 (+258), Inode bitmap at 8452 (+259)
 Inode table at 8453-8703 (+260)　← iノードテーブルのブロック番号
4782 free blocks, 2008 free inodes, 0 directories
 Free blocks: 8704, 9003-9008, 11610-16384 ← 空きブロックの番号
Free inodes: 2009-4016　← 空きiノードの番号

ちなみにBackup superblock（バックアップスーパーブロック）とは。
スーパーブロックのバックアップは、自動的にいくつかのブロックグループの先頭に
作成される。スーパーブロックには重要な情報が含まれているため、いくつかのブロック
 グループを使ってバックアップを取り、保護しているワケだ。
ファイルシステムが壊れた時に使用するfsckは、このバックアップデータからスーパー
 ブロックを修復するのだそうだ。なるほど。

dumpe2fsについての解説や出力結果の見方などは、こちらのサイトを参考にした。

追記
e2fsckでスーパーブロックを修復するコマンド例を。
 以下の”8193″はスーパーブロックのバックアップがあるブロック番号。

# e2fsck -b 8193 /dev/sdb1

###############################################################################
壊れたLVM構成のディスクをどうにかしたい時

壊れたディスクを他のサーバにつないで中身を確認したり復旧させたい時には、デバイスファイルを普通にマウントすればよいだろう。それがLVM構成の場合、どうすればいいだろうか。ググリまくった結果、概ね基本手順は以下でよいと思われる。、、、が、やったことがないので確証はない。
1.壊れたディスクを他のサーバに接続する
2.pvscanで接続先サーバ内のPV（物理ボリューム）を認識させる
3.vgscanで接続先サーバ内のVG（ボリュームグループ）を認識させる
4.vgchange -a y [VG名] で対象VGをアクティベイトする
5.対象LVをマウントする
# mount /dev/VG名/LV名 /マウントポイント
 これで中身を確認したり、データを吸い出したりできる、はず・・・
 ディスクをつないだサーバ内でVG名が重複していると認識できないため、VG名をデフォルトのまま使用していた場合はVG名を変更しなくてはならない。サーバ構築時にVG名をユニークなものにしておくと、後々いいかもしれない。
参照URL 
いろんなサイト見たけど、とりあえず以下挙げておく。
http://ugawalab.miyakyo-u.ac.jp/f6/toshihiro/settei/mount.html
http://blog.matsumoto-r.jp/?p=284
http://www.hdd-pro.com/drd/2009/11/linuxlvm.html
追記
 前提として、ディスクが壊れていたらマウントできない可能性が高いので、上記の操作はスムーズいかないかもしれない。エラーになったらfsck、だろうか。ちなみに-fオプションをつけるとクリーンフラグが立っているファイルシステムも強制的にチェックする。しかし壊れているディスクにさらに強制的にfsckをかけると被害が広がる、という意見もある。その辺りの判断は「これが正解」というのはなさそうである。。

###############################################################################
Linux:LVM解除のおおざっぱなメモ

久しぶりにLVMネタなど。LVMの解除や拡張の手順をまとめてみようかと。
 例のごとく「自分メモ」なので、あまり深く参考にしないでください。
って、深い内容なんてもともとないけど・・・

 まずはLinuxマシンにおけるLVM解除の、おおざっぱなメモ。
 該当ディスクのアンマウント後に実施する。

1.lvdisplay,vgdisplayで現在のステータスを確認。

2.lvremoveコマンドでLVを削除する。
# lvremove /dev/vg_xxxxxx_xxx/LV_Name

3.vgdisplayコマンドでステータス確認。
“CurLV”が、1だったのが0になっているはず…

4.VGを削除する。書式は[vgremove -v VG名 PV名]
# vgremove -v vg_xxxxxx_xxx /dev/sdb2


5.pvdisplayコマンドでVGが削除されたことを確認。
“VG Name”が空白になっているはず。
# pvdisplay -v /dev/sdb2
VGを削除するとPVも同時に削除される仕様になっているので、PVの削除は必要なし（、、、のはず）。

6.fdiskコマンドでパーティションを解除する
# fdisk /dev/sdb2
対話コマンドは、p → d → 2 → p → w の順番で。
※しつこいようですが、この辺はかなり慎重を要する箇所なので鵜呑みにしないように・・・

7.sfdiskコマンドでパーティションが解除されたことを確認
# sfdisk -l /dev/sdb2

8.冗長構成の場合は待機系側の更新を実施
# vgscan
 # sbin/sfdisk -R /dev/sdb2

やはりsfdisk -lで確認する。
この後必要に応じて、マウントポイントディレクトリを削除する。

###############################################################################
Linux:LVM解除後のデータ削除

Linuxマシンにおける、LVM解除後のデータ削除、の簡易メモ。
ディスクをアンマウントしてから実施する。
あまり関係ないかもしれないけど、SAN(Storage Area Network)ディスクに接続
されている環境。

1.dfコマンドで、該当ディスクがマウントされていないことを確認。

2.vgchangeコマンドでVGをアクティベイト。

3.ディスクをマウントする。
# mount -t ext3 -o defaults LV_Name マウントポイントのパス

4.ls -lコマンドでディスクの中身を確認する。

5.rmコマンドで中身を削除する。

6.ディスクをアンマウントする
# umount マウントポイントのパス

7.dfコマンドでディスクがアンマウントされていることを確認してから、
vgchange -a n でVGを非アクティベイトする。

###############################################################################
LVMをまとめてみようと思いついた

LVM(Logical Volume Manager)は難しくて自分には
 よくわからん…的なことを書いたけど、ちょっと調べたり実践したりしているうちに
流れは意外とシンプルなんだなー、という気がしてきた。
そこで、ようやくまとめてみようと決意。

LVM構築の大まかな流れは、以下のようになる。
ディスクのパーティショニング
↓
物理ボリューム(PV)の作成
↓
ボリュームグループ(VG)の作成
↓
論理ボリューム(LV)の作成
↓
ファイルシステムを作成して、マウント

以下、若干詳細な追加の説明。といってもあくまで自分メモなので、「ゆるい」箇所が
 あるかもしれない。その辺はご容赦を。

(1)fdiskでパーティショニング
最初に以下コマンドで共有ストレージのディスクが見えていることを確認。
ここではパーティション名を仮に/dev/sdaとしておく。

# lssd　　　（ディスクの一覧を確認）
# fdisk -l /dev/sda　　　（個別のディスクを確認）

確認できたら、fdisk（またはcfdisk）コマンドにより/dev/sda のパーティションの
 システムタイプをLVMとして保存する。
この操作により、パーティション/dev/sda1 が作成される。

# fdisk /dev/sda
（以降対話式コマンド。詳細は今回は省略）

ちなみに途中”t”オプションでシステムIDを指定するが、LVM パーティションのシステム ID は8e。
また、最後にwで書込みをするまでは、それまでの設定はメモリ上に保存されているだけとなる。
wで書込みをするまではやり直しがきくってこと。

(2)pvcreateで物理ボリュームを作成
 作成したパーティションに対して、pvcreateコマンドで物理ボリュームを作成する。
これによりディスクが初期化される。
LVMパーティションが区画整備される、とも言える。

# pvcreate /dev/sda1

作成後、pvs,pvdisplayコマンドでPV（物理ボリューム）の一覧と割り当てサイズ(PSize)
を確認する。
この時点でのpvsでは、今しがた作成したPVに関して”VG”の箇所にボリュームグループ
 が存在しない。まぁ、当たり前ですけど・・・

(3)vgcreateでボリュームグループを作成
vgcreateコマンドでVGを作成。これによりVGが定義され、同時にPVの中にPEが作成
される。PEサイズはデフォルトで4MBとなっている。
 他のサイズにするには、-sオプションで明示的に指定する。

 書式は “vgcreate option VG NAME device file name” となる。
ひとつのVGの配下に複数のデバイスファイルを所属させるには、以下のように続けて指定する。

#vgcreate -s 32M VG NAME /dev/sda1 /dev/sdb1 /dev/sdc1

作成後pvsでPVのステータスを確認すると、”VG”の箇所に先ほどは存在しなかった
 ボリュームグループ名が表示されているはず。

vgs,vgdisplayでVGのステータスを確認する。ちなみに上記のよう3つのデバイスファイルを
配下に作成してvgdisplayすると、Logical volumeのSegmentが3になるはず（通常は1）。

(4)lvcreateで論理ボリュームを作成
lvcreateコマンドで、論理ボリュームを作成する。
-lオプションでサイズを、-nオプションで論理ボリューム名を指定する。
ここで指定するサイズとはpvdisplayした時のTotal PEの値となる。

# lvcreate -l 434 -n LV NAME VG NAME

lvcreateは、普通のHDで言うところの「パーティションを切る」作業に当たると思うけど、
よく「LVを切る」って言い方もしますね。
ちなみに「PEサイズ× Total PEの値=PVサイズ（物理的なディスクサイズ）」となる。
また、作成後、pvs,vgsすると、PFreeやVFreeが0になっているはず。

lvs,lvdisplayで論理ボリュームのステータスを確認しておく。

(5)ファイルシステムの作成(mkfs)
 mkfsコマンドで、論理ボリュームに対してファイルシステムを作成する。
ファイルシステムタイプはext3,XFS等、環境に応じて指定。
 以下の例ではext3としている。

# /sbin/mkfs.ext3 LVのパス
ここで冗長構成の場合は待機系パーティションテーブルを更新し、vgscanでVGの認識をさせる。
 以下その流れ。

1.現用系でVGを非アクティベイト
# vgchange -a -n VG NAME

2.待機系でパーティションテーブル更新
# /sbin/sfdisk -R /dev/sda

3.待機系でVGの認識をさせる
# vgscan VG NAME

4.LVM構成情報のバックアップファイルを取得
# vgcfgbackup VG NAME

4.現用系でVGをアクティベイト
# vgchange -a -y VG NAME

(6)マウント(mount)
マウントポイントとなるディレクトリを作成後、mountコマンドでマウントする。
# mount -t ext3 LVのパス マウントポイントのパス

dfコマンドでマウントされたかどうか確認する。
# df -m | grep /dev/sda

なーんだ、これだけだったのか（といいつつ、また長くなってしまった）。
…って、最近になってようやくつかめてきたんだけど（汗）
しかし、どんな分野でも分かってくるとうれしいものだw

###############################################################################
pvs,pvdisplayで物理ボリュームの確認

pvs,pvdisplayコマンドで物理ボリュームのステータスを確認できる。

ちなみに自分が確認した時、ちょっと古いバージョンのOSではpvsは使えなかった。
lvm1だとないのかな。RHELのバージョンによる？その辺は深追いはしないでおく。

以下は出力結果例。
#--------------------------------------
#pvs
  PV           PV             Fmt     Attr    Psize  Pfree
 /dev/sda1     <VG NAME>      lvm2     a-     13.5G    0
#--------------------------------------
前回にも書いたけど、もしこの時点で所属するべきVGが作成されていないPVがあったら、
2列目のVGの箇所が空白となっている。
 以下、pvdisplayの出力結果例。

前回にも書いたけど、もしこの時点で所属するべきVGが作成されていないPVがあったら、
2列目のVGの箇所が空白となっている。
 以下、pvdisplayの出力結果例。

#--------------------------------------
# pvdisplay
 ----- Physical volume -----
 PV Name            /dev/sda1
 VG Name            <VG NAME>
 PV size            13.5G / not usable 0
 Allocatable        yes(but full)
 PE Size(KByte)     32768
 Total PE           434
 Free PE            0
 Allocated PE       434
PV UUID             --------------
#--------------------------------------

以下、各項目の説明を。

PV NAME,VG NAME 　PV名、VG名を表示。

PV Size 対象のPVの有効サイズを表示。

Allocatable　割り当て可能かどうかを表示。
※利用可能な状態ですべての領域を割り当て済みの場合、”yes (but full)”と表示。

PE Size (KByte)　PEのサイズを表示。

Total PE　割り当て可能な最大のPE数を表示。
ちなみに、”PE Size” × “Total PE” = “PV Size” となる。

Free PE　割り当て可能なPE数を表示。すべて割り当て済みの場合は 0 となる。

Allocated PE　割り当て済みのPE数を表示。
ちなみに、”Total PE”   “Allocated PE” = “Free PE”となる。

PV UUID　PVに割り当てられたユニークなID、識別子。 

###############################################################################
vgs,vgdisplayでボリュームグループの確認

vgdisplayについては以前の投稿でも書いているけれど、もう一度別の観点からまとめて
 みようと思う。それと、vgsコマンドについても少し。

vgsコマンドはVG（ボリュームグループ）の一覧を出力する。サーバに存在するVGを
 サクッと確認したい時にいいと思う。実行結果は以下のような感じ。

#--------------------------------------
# vgs
 VG               #PV    #LV    #SN     Attr       VSize     VFree
 <VG NAME_01>      1      1      0      wz-n-      13.5G      0
 <VG NAME_02>      1      1      0      wz-n-      13.5G      0
 <VG NAME_03>      1      5      0      wz-n-      16G       512M
#--------------------------------------

上の例ではVG NAME_03は、#LVを見ると5つのLVを含んでいるのが確認できる
（lvsするとその詳細がわかる）。
それと例にはないのだが、あるVGが複数のPVから作成されていると、#PVにはそのPVの数が表示される。

vgdisplayのおさらい。前回では省略したけど、vgdisplayコマンドの実行結果は以下のイメージ。

#--------------------------------------
# vgdisplay
 ----- Volume group-----
 VG Name                  <VG NAME_01>
 System ID          
 Format                   lvm2
 Mata data Areas          1
 Mata data Sequence No    150
 VG Access                read/write
 VG Status                resizable
 MAX LV                   0
 Cur LV                   1
 Open LV                  1
 Max PV                   0
 Cur PV                   1
 Act PV                   1
 VG size                  13.5G
 PE Size                  32.0MB
 Tatal PE                 434
 Alloc PE / Size          434/13.5G
 Free PE / Size           0/0
VG UUID             --------------
#--------------------------------------

項目の意味に関して、主なところを抜粋すると。
VG Name　ボリュームグループ名
Format　LVMのバージョン。カーネル2.6.*ならlvm2のはず。
Cur LV　論理ボリュームの数
Cur PV　物理ボリュームの数
VG Size　ボリュームグループのサイズ
PE Size　物理エクステントのサイズ
Total PE　物理エクステントの総数
Alloc PE　割当済みPE数
Free PE　空きPE数 

上の例で言うと、Total PEのうち全てのPEが割り当て済みなので、空きPEは0になって
 いる。ちなみにしつこいようだが、” PE Size x Total PE = VG Size”となる。

vgdisplay と vgdisplay -v の使い分けなのだが、vgdisplay -vだとVGの情報だけでなく
LVとPVの情報も一緒に表示してくれる。
つまり、vgdisplay -v でのLVの出力結果と、lvdisplayの出力結果は同じ内容なのである。
ただし、PVについては、Physical volumesで表示される情報は簡易版となる。

（これ以降、戯言なので読み飛ばしてもらっていいです。自分でも読み返して何を言いたかったのか
 よくわからない。。）

 例えば、VGを非アクティベイトしてから# vgdisplay -v VG NAMEでLVのステータスを確認すると、
Logical volumeの項目、LV Status がNot availableになっているのが見える。
このVGをvgchangeコマンドでアクティベイトしてからもう一度LV Statusを見ると、
available に変わっているはず。

# lvdisplay VG NAME ( or LV NAME )でも同じ出力結果が確認できるので、
どっちでもいいわけだが、うーむ、やはりvgdisplay -vで一緒に確認すればいいじゃん、という気が…

###############################################################################
usage of vgdisplay

Linuxで使われるLVMのコマンド、vgdisplay。
LVM(Logical Volume Manager)とは何か、なんてところから始めると話が大きく
 なってしまうので、取り急ぎLVM関連で頻繁に使用すると思われる、vgdisplayに
 ついてまとめておこうかな、と。

vgdisplayは何かというと・・・英文manから抜粋して、内容をまとめてみた。

#--------------------------------------
vgdisplay   display attributes of volume groups

vgdisplay allows you to see the attributes of VolumeGroupName (or all volume groups if none is given) with it’s physical and logical volumes and their sizes etc. 
#--------------------------------------
以下、意訳入ってるけどこんな感じかと。

「vgdisplay   ボリュームグループの情報を表示する」
ボリュームグループ名を指定した場合はそのボリュームグループの、そうでなければすべての
 ボリュームグループについて、物理及び論理ボリュームのサイズ、その他属性情報を表示する。
 （そもそもボリュームグループとは何か、というのは今回は割愛）

 以下、hp社のサイトからの抜粋ですが、言っていることは同じ。
 最後に、「ボリュームグループは表示する前にアクティベイト（活性化）しておく必要がある」
と一言添えてある。
#--------------------------------------
vgdisplay   display information about LVM volume groups

The vgdisplay command displays information about volume groups. For each vg_name specified, vgdisplay displays information for that volume group only. If no vg_name is specified, vgdisplay displays names and corresponding information for all defined volume groups.

The volume group must be activated (see vgchange(1M)) before it can be displayed.
#--------------------------------------
ちなみに上記については翻訳版のページもあるのだが、機械翻訳入っているので正直意味不明
だったり・・・
英語ページとはいえシンプルな表現が続くので、英語で読んだ方が、翻訳版よりもかえって
頭に入りやすい気が、する。
では、オプションの説明についてよく使いそうなのをピックアップ。
#--------------------------------------
-v
--verbose
#--------------------------------------
Display verbose information containing long listings of physical and logical volumes. If given twice, also display verbose runtime information of vgdisplay’s activities.

詳細な情報を表示する。2回繰り返すと、vgdisplayアクティビティのランタイムインフォメーションも詳細に表示する。

一番よく使われるオプションではないだろうか。
verboseは「冗長な、くどい」などの意味だが、コンピュータ関連においては「詳細な」となる。
-vオプションは他にも多くのコマンドに使われるけど、もとはverboseなんですね。
 （って、以前も調べておいて「ふ0ん」と思ったはずなんだが、すぐ忘れてしまう）

vgdisplay -vで表示される情報は以下の通り（実際の出力結果はまた別）。
 翻訳したところで”physical extent size”が「物理エクステントサイズ」になるだけなので、詳細は省略。

#--------------------------------------
1 volume group name
 2 volume group access
 3 volume group status
 4 internal volume group number
 5 maximum number of logical volumes
 6 current number of logical volumes
 7 open count of all logical volumes in this volume group
 8 maximum logical volume size
 9 maximum number of physical volumes
 10 current number of physical volumes
 11 actual number of physical volumes
 12 size of volume group in kilobytes
 13 physical extent size
 14 total number of physical extents for this volume group
 15 allocated number of physical extents for this volume group
 16 free number of physical extents for this volume group
 17 uuid of volume group
#--------------------------------------

あと、vgdisplay -vv。
-vvで出力される「ランタイムインフォメーション」ってそもそも何、って感じだが、
 出力結果をみると、以下のようにVGの情報を捉える過程というか、findしている様子が
表示されるようだ。少なくとも自分は普段必要とすることはなさそうだが・・・

# vgdisplay -vv
#--------------------------------------
 Setting global/locking-type to 1
 Setting global/locking-dir to /var/lock/lvm
 File-based locking enabled

 Finding all volume groups

 /dev/ramdisk : No label detected
 /dev/root : No label detected
（略）
/dev/cciss/c0d0p2 : lvm2 label detected
（略）
Unlocking /var/lock/lvm/VG NAME
 Locking /var/lock/lvm/VG NAME RB

 Finding volume group “VG NAME”
（略）
#--------------------------------------
vgdisplay -cとは…
#--------------------------------------
-c
--colon
#--------------------------------------
Generate colon seperated output for easier parsing in scripts or programs.

スクリプトやプログラムにおいて解析しやすいように、コロンで区切られた出力結果を表示する。

出力結果は、上記のとおりそのまんま、です。
それから、vgdisplay -s。
#--------------------------------------
-s
--short
#--------------------------------------
Give a short listing showing the existence of volume groups.

あっさりした情報だけ表示、ってところかな。
 出力結果は以下のような感じ。VGのサイズだけちょっと確認したい時なんかによいのだろーか？

# vgdisplay -s
“VG NAME” 15.00GB [15.00GB used / 0MB free]
“VG NAME” 16.00GB [16.00GB used / 0MB free]

以下は、まぁ、そのまんま。
#--------------------------------------
-h
--help
--version
#--------------------------------------

あとは、こんなのも。
#--------------------------------------
-A
--activevolumegroups
#--------------------------------------
Only select the active volume groups.

アクティブなボリュームグループのみ選択して表示

これはちょっと、条件がそろってる時じゃないと出力結果の確認はできないので、
 機会があったら見てみようと思いマス。

【追記】
この後、機会があったので以下の状態で試してみた。
# vgchange -a n VG NAME で対象のVGを非アクティベイト
↓
 # vgdisplay -A

・・・が、対象VGの情報は表示された。
なので、「アクティブなボリュームグループ」っていうのがどういう状態なのか、
よくわかりません。

LVMは深いので、そう簡単には身に付かない。
でも、「あーだこーだ」とやっているうちに「あ、そういうことか」とつかめる時がきたりする。


###############################################################################
lvs,lvdisplayで論理ボリュームの確認

LVMシリーズの最後はlvsとlvdisplayをうっすらと説明（最後じゃないかもしれないけど、
 一応区切りをつけるためにw）。
lvsは以下のように、LVの一覧を表示する。

#--------------------------------------
# lvs
   LV           VG           Attr     LSize   Origin Snap%  Move Log Copy%
   lv_name_01   VG_NAME_01   wi-ao   13.5G
   lv_name_02   VG_NAME_02   wi-ao   13.5G
   lv_home      VG_NAME_03   wi-ao    4.5G
   lv_root      VG_NAME_03   wi-ao   2.00G
   lv_tmp       VG_NAME_03   wi-ao   2.00G
   lv_usr       VG_NAME_03   wi-ao   4.00G
   lv_var       VG_NAME_03   wi-ao   3.00G
#--------------------------------------

vgsした時にあるひとつのVGに対して、複数のLVが存在する
 のが見えたとする。lvsすると、その複数のLVの詳細が分かる（下の5行がそれ）。

lvdisplayの出力結果はこんな感じ。ちなみにLV UUIDの箇所は何らかの値が入る
（文学通り、ユニークなID）。

#--------------------------------------
# lvdisplay
   --- Logical volume ---
   LV Name               lv_name_01
  VG Name                VG_NAME_01
   LV UUID               m2sx31-yglu-wjsG-yqq0-WPPn-3grk-n2LJBD
   LV Write Access       read/write
   LV Status             available
   # open                1
   LV Size               13.5 G
   Current LE            434
   Segments              1
   Allocation            inherit
   Read ahead sectors    0
   Block device          253.07
#--------------------------------------

自分が確認するのは、とりあえずLV Nameと、LV StatusがavailableかNot available、くらいかな。
 他のLVMシリーズのコマンド同様、引数に何も指定しなければすべてのLVの情報を、
LV名を指定するとそのLVの情報のみ表示する。ちなみに、ここではLV名ではなく
VG名の指定も可能。

以前、# lvdisplay lv_nameとコマンドを実行したら、そんなlvないよ、と返されたことがある。
 「lvsで表示されているlv_nameなのに、何で」と思ったら、フルパスで指定したらOKだった。
いちいちフルパスで指定しないと駄目なのかw
まぁ、こういうこともあるってことで・・・

###############################################################################
Linux:LVM拡張手順のメモ

ディスク追加に伴うLVM拡張の手順メモ。
ちなみにクラスタソフトウェアを利用した冗長構成のDBサーバ、という環境を想定。
クラスタソフトの箇所はちょっと、詳細は省略させてもらうとして・・・
 あとメモと言っておきながら長くなりそうなので、前半／後半に分けますw

1.現用系マシンにてディスク容量の確認

#df -h
 # vgdisplay -v VG名

2.ディスク情報の確認。接続しているストレージによりコマンドが変わる。
DMX(EMC)の場合 syminqコマンドで一覧表示する。
 見づらいようなら、パイプ & grep -v 等を利用して不要な箇所を非表示に。
XP(HP)の場合はlssdコマンドで。

3.クラスタソフトを停止する

4.dfコマンドで対象のマウントポイントがアンマウントされていることを確認。

5.対象デバイスファイルに対し、fdiskコマンドでディスク領域の確保をする。
sfdisk -lで状態を確認する。

# sfdisk -l /dev/sdb

6.pvcreateコマンドでPVを作成。

# pvcreate /dev/sdb1

7.vgchangeコマンドでVGをアクティベイト。

# vgchange -a y VG名

8.vgextendコマンドでVGを拡張する。
書式: vgextend VG名 追加した領域

# vgextend VG名 /dev/sdb1

領域が複数ある場合はその分だけ繰り返す。

9.vgdisplay -v VG名コマンドでPVが追加されていることと、ディスク容量を確認。

LinuxマシンにおけるLVM拡張手順メモの後半。
VGの拡張に引き続き、ここからLVの拡張に入ります。

10.対象のlvol(LV)にfsckを実施する。

# e2fsck /dev/vg_xxxxxx_xxx/LV_Name

11.e2fsadmコマンドによりLVを拡張する。

# e2fsadm -l+434 /dev/vg_xxxxxx_xxx/LV_Name

上の”434″は一例ではあるが、Free PEの値（vgdisplayで確認）。
このサイズより大きい容量は割当できない。
補足：e2fsadmは環境によっては使用しないかも。
その場合はlvextendコマンドを利用する。この辺りは次回にでも。

12.対象のLVをマウントする。

# mount LVパス マウントポイント
# df -h
 # vgdisplay -v
 ※ディスク容量やステータスを確認

13.対象のLVのアンマウントを実行。

14.VGのバックアップを取得する。

# vgfgbackup VG名

15.vgchange -a n でVGを非アクティベイトする
待機系マシンにログインする。
※冗長構成のため、待機系にもLV拡張を反映させる。やることは基本的に現用系と同じ。

16.パーティションテーブルを更新する

# sfdisk -R /dev/sdb1

17.vgscan -v でVGを認識させる。

18.vgchange -a y でVGをアクティベイトする。

19.対象のLVをマウントする。

# mount LVパス マウントポイント
# df -h
 # vgdisplay -v
 ※ディスク容量やステータスを確認

20.対象のLVのアンマウントを実行。

21.VGのバックアップを取得する。

# vgfgbackup VG名

22.vgchange -a n でVGを非アクティベイトする

23.クラスタソフトを起動する。適宜ステータスを確認。

24.MySQLに接続できることを確認する。

25.クラスタソフトを停止し、待機系マシンからログアウトする。

26.現用系マシンにログインし、クラスタソフトを起動する。
ステータスが正常であることを確認できたらOK。

この後は必要に応じてDB（ここではMySQL）のデータファイルを追加する作業を行う。

###############################################################################
LV拡張時のコマンド e2fsadm

LV拡張時のコマンドe2fsadmは、
 商用ツールであるとかLVMパッケージの一部であるとか書かれており、…実際のところ、
 自分もよく分かっていない。また、e2fsadmを利用していない環境も多いと思われる。
 （その辺りも不明…）

ともあれ、e2fsadmを使用しない場合はlvextendコマンドでも良い。以下例。

# lvextend -l+434 /dev/vg_xxxxx_xxx/LV名

ただしこの場合、LVが拡張されただけでファイルシステムは拡張されていない。
よって、追加で以下のようにファイルシステムを拡張する手順も必要となる。

# resize2fs /dev/vg_xxxxx_xxx/LV名

※サイズを指定しなくても自動的にLVに合わせてファイルシステムを拡張してくれる。
また、拡張時はファイルシステムをマウントした状態（オンライン）でサイズ変更
が可能（縮小時はアンマウントする）。

e2fsadmを利用すれば追加の手順は不要。
おそらく、LV拡張とファイルシステム拡張を一括でやってくれるのだろう。

ただし、e2fsadmはそれほど多く使用されてはいないらしく、現在も普及している
 ものかどうか、
また代替となるコマンドがlvextendの他にあるのか、その辺も今イチ。
この程度の話で恐縮ではあるけれど、一応メモを残しておこうと思うw

###############################################################################
LVM スナップショットの覚え書き

Linuxでバックアップに利用されるLVMの機能、スナップショット。
スナップショットは単にデータのコピーを取るのではなく、対象となる論理ボリュームにおける、その瞬間のポインタを捉える。もっと一般的な言い方をすると、「ある瞬間のファイルシステムイメージを保持」したもの。

 捉えられたポインタはスナップショット領域に保持されるわけだが、スナップショットを作成した瞬間のポインタがそのまま保持されるのではない。ファイルシステム上でなんらかの変更があれば、スナップショット領域内において差分が更新される。さらに、スナップショット領域内には変更前のデータ（のポインタ？）も退避され、保存される。

….と、いうことらしい。この辺りはちょっと難しい。。
 仕様については切り上げて、実践編。

スナップショットを作成するには、lvcreateに-sオプション、もしくは snapshotをつける。-nで領域の名前を指定する。以下は、論理ボリューム”/dev/vg_name/lv_name”のスナップショットをsnap_testという名で作成している。
※スナップショット用の領域が確保されていることが前提。ないと怒られる。

# lvcreate -s -L 200MB -n snap_test /dev/vg_name/lv_name

作成後lvdisplayしてみると、スナップショット領域が出来上がっているのが確認できるだろう。
 作成したスナップショットは、dumpやrsyncなど利用してバックアップに使える。スナップショットは通常のデバイスと同じように扱えることができて、dumpでテープにバックアップを取るのであれば以下コマンドでOK。

# dump 0uf /dev/st0 /dev/vg_name/snap_test

rsyncを実行する場合は、スナップショットをマウントしておく。

# mount -r /dev/vg_name/snap_test /mnt/snap_point　
snap_testを”/mnt/snap_point”にマウント

※rsyncコマンド例は今回は割愛。気が向いたら追記。
スナップショット領域は放っておくとどんどん増えていくので、バックアップが済んだら速やかに削除する。

アンマウントしてからlvremoveする。

# umount /mnt/snap_point
 # lvremove -f /dev/vg_name/snap_test　←-f は forceでも。

スナップショットの説明は以下サイトが分かりやすいかも。
http://www.atmarkit.co.jp/flinux/rensai/root06/root06b.html

###############################################################################
