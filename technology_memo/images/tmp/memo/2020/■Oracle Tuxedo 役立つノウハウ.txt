■Oracle Tuxedo 役立つノウハウ

ここでは、Tuxedo システムの設計および管理・運用に関するあらゆるノウハウをご紹介します。

━━━━━ 目次 ━━━━━
日本語 HP-UX 環境において、y/n の入力を有効にする
ひとつのサーバプロセスに複数のサービスを定義する場合
サーバプロセスを多重化する
タイムアウト値は厳密ではない
エラーメッセージに強くなる
詳細トレースログを出力するには
BLOCKTIME とトランザクションタイムアウト
BLOCKTIME には２種類ある
メッセージキューの滞留状況の確認方法
MSSQ はサーバの増やしすぎに注意
メッセージキューがあふれる条件は？
HP-UX における MSGMNB の最大値について
/Qは重い？
優先度つきのサービス呼び出しについて
メッセージキューアクセスの競合と SPINCOUNT
Tuxedo が作成する IPC 資源の管理
サーバの自動再起動機能の動作について
サーバ多重化時のサーバIDに注意
トランザクションのリトライは余裕を持って
完全なシャットダウンはなかなか難しい
syslog にイベントを出力する
WSL の -N オプションの注意点 ― Nagle アルゴリズムによるネットワーク遅延
RM（リソース・マネージャ）の使い方
ファイアウォールを越えて /WS クライアントが接続するには？
ULOG に出力されるメッセージを運用管理製品から監視するには？
━━━━━━━━━━━━━━━━━━━━

●日本語 HP-UX 環境において、y/n の入力を有効にする

日本語 HP-UX 環境において、tmboot や tmshutdown などのコマンドにおける y/n の入力を有効にするには、以下の作業を行う必要があります。
1.スーパーユーザの権限で作業を行います。作業環境が英語 locale（環境変数 LANG および LC_ALL などの内容が「C」）であることを確認します。

2.locale 定義ファイルを、作業ディレクトリにコピーします。

$ cd /tmp
$ cp /usr/lib/nls/loc/src/ja_JP.SJIS.src .
$ cp /usr/lib/nls/loc/src/ja_JP.euc.src .

3.コピーした ja_JP.SJIS.src および ja_JP.euc.src の LC_MESSAGES セクションに、以下に示す 2 行を追加します。（実際のファイルの内容はやや異なる場合があります）

# LC_MESSAGES
#
LC_MESSAGES
yesstr "<y><e><s>"　　　←　この 2 行
nostr "<n><o>"　　　　　←
yesexpr "^[<y><Y><j0389><j0357>]"
noexpr "^[<n><N><j0378><j0346>]"
#
END LC_MESSAGES

4.ファイルをコピーした作業ディレクトリで以下のコマンドを実行します。（大量の警告が出ますが問題ありません）
$ localedef -c -n -f /usr/lib/nls/loc/charmaps/SJIS.cm -i ja_JP.SJIS.src ja_JP.SJIS
$ localedef -c -n -f /usr/lib/nls/loc/charmaps/eucJP.cm -i ja_JP.euc.src ja_JP.eucJP

5.元の locale 定義ファイルを削除します。"text file busy" エラーが出て削除できない場合は、別のファイル名や作業ディレクトリなどに mv しておき、後でマシンを再起動した際に削除してください。

※ HP-UX PA-RISC (11.0, 11.11, 11.23) 32-bit 版のTuxedo
$ rm /usr/lib/nls/loc/locales/ja_JP.SJIS
$ rm /usr/lib/nls/loc/locales/ja_JP.eucJP

※ HP-UX PA-RISC (11.11, 11.23) 64-bit 版のTuxedo
$ rm /usr/lib/nls/loc/pa20_64/locales/ja_JP.SJIS
$ rm /usr/lib/nls/loc/pa20_64/locales/ja_JP.eucJP

※ HP-UX Itanium (11.23) 32-bit 版のTuxedo
$ rm /usr/lib/nls/loc/hpux32/locales/ja_JP.SJIS
$ rm /usr/lib/nls/loc/hpux32/locales/ja_JP.eucJP

※ HP-UX Itanium (11.23) 64-bit 版のTuxedo
$ rm /usr/lib/nls/loc/hpux64/locales/ja_JP.SJIS
$ rm /usr/lib/nls/loc/hpux64/locales/ja_JP.eucJP

6.作業ディレクトリに作成した locale 定義ファイルを /usr/lib/nls/loc/locales にコピーします。

※ HP-UX PA-RISC (11.0, 11.11, 11.23) 32-bit 版のTuxedo
$ cp ja_JP.SJIS /usr/lib/nls/loc/locales/
$ cp ja_JP.eucJP /usr/lib/nls/loc/locales/

※ HP-UX PA-RISC (11.11, 11.23) 64-bit 版のTuxedo
$ cp ./pa20_64/ja_JP.SJIS /usr/lib/nls/loc/pa20_64/locales/
$ cp ./pa20_64/ja_JP.eucJP /usr/lib/nls/loc/pa20_64/locales/

※ HP-UX Itanium (11.23) 32-bit 版のTuxedo
$ cp ja_JP.SJIS /usr/lib/nls/loc/hpux32/locales/
$ cp ja_JP.eucJP /usr/lib/nls/loc/hpux32/locales/

※ HP-UX Itanium (11.23) 64-bit 版のTuxedo
$ cp ./hpux64/ja_JP.SJIS /usr/lib/nls/loc/hpux64/locales/
$ cp ./hpux64/ja_JP.eucJP /usr/lib/nls/loc/hpux64/locales/ 

以上 1 ～ 6 の作業を行うことによって、日本語環境において y/n の入力が認識されるようになります。

また、この現象を一時的に回避するには、LANG 環境変数を C（英語）に設定するか、各コマンドの -y オプション（ y/n の確認をせず、直ちに処理を開始する）を使用する方法もあります。


●ひとつのサーバプロセスに複数のサービスを定義する場合

ひとつのサーバプロセスに複数のサービスを定義することには、以下の利点があります。
サーバー数を減らすことで、使用リソース（共有メモリ、セマフォ、メモリ）を軽減できます。 
起動停止時間が低減できます。

ひとつのサーバプロセスに複数のサービスを定義する場合、サーバプロセス単位で行うコンフィギュレーションの設定値は、そのサーバプロセスに含まれるサービス全体に影響します。すなわち、すべてのサービスで設定が同じでなければなりません。たとえば、SERVERS セクションの ENVFILE などが挙げられます。

さらに、最も注意しなければならないのは、トランザクションへの参加の有無です。
AUTOTRAN キーワードはサービスごとに設定できるにもかかわらず、おなじサーバプロセス上で定義されるサービスで、あるサービスだけはトランザクションに関与し、そのほかのサービスはトランザクションに関与しないなどということはできません。トランザクションへの関与はサーバプロセス単位となります。

●サーバプロセスを多重化する

同じサーバプロセスを多重化するには、以下の二つの方法があります。

SSSQ（Single Server Single Queue：サーバプロセスごとにメッセージキューがひとつずつ）を設定する
SSSQ を設定したいサーバプロセスについて、UBBCONFIG ファイルで以下のように設定します

simpserv SRVGRP=GROUP1 SRVID=100 MAXGEN=1 GRACE=60MIN=5MAX=5 RESTART=Y

MIN=5 を設定することにより、simpserv サーバプロセス起動時に自動的に 5 つのサーバプロセスが起動し、多重化されます。

MSSQ（Multiple Server Single Queue：複数のサーバプロセスでひとつのメッセージキューを共有）を設定する
SSSQ と似ていますが、RQADDR により共有するメッセージキュー名を指定し、REPLYQ=Y を設定する必要があります。

simpserv2 SRVGRP=GROUP1 SRVID=110 MAXGEN=100 GRACE=60MIN=10MAX=10RQADDR=simp2 REPLYQ=YRESTART=Y

ここで、RQADDR に指定するメッセージキューの名前は、MSSQ サーバセットごとに一意な名前であれば、自由につけてかまいません。
以下に、それぞれのモデルの特長と欠点を示します。

モデル
SSSQ
MSSQ

メリット 大量の要求に対応することができ、負荷分散によりスループットをあげることができる いずれかのサーバがダウンしても、溜まっている要求は残りのサーバが処理する 
デメリット いずれかのサーバがダウンすると、そこに溜まっていた要求を処理できなくなってしまう 大量の要求があると、メッセージキューがあふれやすい 

SSSQ と MSSQ を組み合わせることにより、両モデルの欠点を補完することができます。すなわち、MSSQ サーバセットを多重化することによって、要求メッセージのロストを抑止し、さらに大量の要求が到着した場合でも負荷を分散し、メッセージキューをあふれにくくすることができるようになります。

simpserv2 SRVGRP=GROUP1SRVID=110MAXGEN=100 GRACE=60 MIN=10 MAX=10 RQADDR=simp2_1 REPLYQ=Y
simpserv2 SRVGRP=GROUP1SRVID=120MAXGEN=100 GRACE=60 MIN=10 MAX=10 RQADDR=simp2_2 REPLYQ=Y

こちらもご覧ください　>>Tuxedo の機能・特長[SSSQ と MSSQ]

●タイムアウト値は厳密ではない

Tuxedo は、内部タイマとして SCANUNIT（最小値 5 秒、デフォルト 10 秒） を基本として動作しています。つまり、タイムアウトの検出なども、最大で ＋SCANUNIT の誤差が生じてしまいます。
タイムアウトのタイミングを利用して複雑な仕組みを構築しようとする場合、このことに十分注意する必要があります。

●エラーメッセージに強くなる

障害が発生した場合、ULOG 内の出力メッセージを参照することによって、簡単に問題箇所を特定し、解決できる場合があります。エラーメッセージなどを参照しても原因が特定できない場合、収集した情報とともに、メールにてお問い合わせください。

エラーが生じたTuxedoシステムが出力していたULOGファイルをエディタなどで開き、エラーメッセージを探してください。その際、以下の２つのキーワードが手がかりとなります。

1.メッセージ・カタログ
メッセージ・カタログは、ULOG 中に出力される ??????_CAT:xxx という形式のメッセージを元にその意味を調べます。?????? の部分に出力されている文字列はカタログ名であり、Tuxedo オンライン・マニュアルの《メッセージ（またはシステム・メッセージ）》 に各メッセージ・カタログへのリンクがあります。該当するメッセージ・カタログを探し出したら、xxx の部分に出力されている番号に対応するメッセージを読み、エラー原因を推定します。

2.tperrno
tperrnoは、ATMI関数などがエラーリターンした際に、そのエラーの種類を示す番号であり、Tuxedo ランタイムシステムによって自動的にセットされます。tperrno の各値に対する意味は以下のとおりです。なお、tperrnoの値は ${TUXDIR}/include/atmi.h 内で define されており、各値の意味は、それぞれのキーワードを元に、Tuxedo オンライン・マニュアルの《リファレンス → セクション5 → tperrno(5)》 で確認することもできます。

値 エラーの種類 一般的な意味
1 TPEABORT イニシエータまたは 1 つ以上のパーティシパントによって実行される処理がコミットできなかったために、トランザクションがコミットできませんでした。 
2 TPEBADDESC 呼び出し記述子が無効であるか、あるいは、会話型サービスを起動したときに使用した記述子ではありません。 
3 TPEBLOCK ブロッキング条件が存在しますが、TPNOBLOCK が指定されました。 
4 TPEINVAL 無効な引数がありました。 
5 TPELIMIT 未終了の要求数またはコネクション数が最大数に達したために、呼び出し側の要求が送信されませんでした。 
6 TPENOENT svc が存在していない、またはそれが正しいサービス型でないためにsvcに送信できませんでした。 
7 TPEOS オペレーティング・システムのエラーが発生しました。 
8 TPEPERM クライアントは、アプリケーションに参加できません。その理由は、クライアントがアプリケーションへの参加を許可されていない、または正しいアプリケーションのパスワードを提供されていないためです。 
9 TPEPROTO ライブラリ・ルーチンは、不正なコンテキストで呼び出されました。 
10 TPESVCERR サービス・ルーチンは、tpreturn() または tpforward() のいずれかにおいてエラーを見つけました (たとえば、不正な引数が渡されました)。 
11 TPESVCFAIL 呼び出し側の応答を送信するサービス・ルーチンが、TPFAIL で tpreturn() を呼び出しました。これは、アプリケーション・レベルの問題です。 
12 TPESYSTEM BEA Tuxedo システム のエラーが発生しました。 
13 TPETIME タイムアウトが発生しました。 
14 TPETRAN 呼び出し側がトランザクション・モードになりません。 
15 TPGOTSIG シグナルが受信されましたが、TPSIGRSTRT は、指定されませんでした。 
16 TPERMERR リソース・マネージャは、オープンまたはクローズに失敗しました。 
17 TPEITYPE 入力バッファのタイプおよびサブタイプは、サービスが扱うタイプおよびサブタイプの 1 つではありません。 
18 TPEOTYPE 応答のタイプおよびサブタイプは、呼び出し側に認識されていません。 
19 TPERELEASE TPACK が指定されましたが、ターゲットは承認プロトコルをサポートしない旧リリースの BEA Tuxedo からのクライアントです。 
20 TPEHAZARD ある種の障害のため、トランザクションの一部としてなされた作業がヒューリスティックに完了している可能性があります。 
21 TPEHEURISTIC ヒューリスティックな判断により、トランザクションの代わりに行われる処理の一部はコミットされ、一部は中途終了 (アボート) されました。 
22 TPEEVENT イベントが発生しました。イベントのタイプは revent で返されます。 
23 TPEMATCH svcname は、すでにこのサーバについて宣言されていますが、それは、func 以外の関数で行われました。 
24 TPEDIAGNOSTIC 指定されたキューへのメッセージの登録が異常終了しました。異常終了の原因は、ctl を介して返される診断値によって判別できます。 
25 TPEMIB 管理要求が失敗しました。outbuf が更新され、MIB(5) および TM_MIB(5) で説明するエラーの原因を示す FML32 のフィールドが設定され、呼び出し側に返されました。 

●詳細トレースログを出力するには

詳細トレースモードを設定すると、ULOG に Tuxedo ランタイムシステムの内部コールの詳細トレースが出力されるようになります。
以下に示した、詳細トレースモードの設定方法①～③のいずれかの方法で詳細トレースモードを設定および解除することができます。
1. 環境変数 TMTRACE に xa+iatmi+atmi:ulog:dye をセットする
Tuxedo を起動したシェルから、環境変数 TMTRACE を設定します。

$ setenv TMTRACE xa+iatmi+atmi:ulog:dye （cshの場合）

環境変数 TMTRACE を設定すると、その時点から詳細ログが ULOG に出力されるようになります。
また、詳細トレースモードを解除するには、同じシェルから次のように入力します。

$ unsetenv TMTRACE （cshの場合）

2.tmadmin コマンド内で直接開始する
ENVFILE を利用していない場合は、以下のように tmadmin 内でトレースレベルを直接指定することができます。

$ tmadmin
> chtr -m MACHINE1 atmi+iatmi+xa:ulog:dye
> q

TMTRACE に設定できるキーワードの種類とそれぞれの意味は、Tuxedo オンライン・マニュアル《リファレンス → セクション5 → tmtrace(5)》 を参照してください。
また、tmadmin の changetrace(chtr) コマンドについては、Tuxedo オンライン・マニュアルの《リファレンス → セクション1 → tmadmin(1)》 を参照してください。

●BLOCKTIME とトランザクションタイムアウト

トランザクションモードでは、BLOCKTIME によるタイムアウトは発生しません。トランザクションモードでは、トランザクションタイマが BLOCKTIME の代わりに使用されます。（ WSL などのタイムアウトはトランザクションモードでも監視されます。）

●BLOCKTIME には２種類ある

DOMAIN 内のトランザクションでは、BLOCKTIME は無効になりますが、DOMAIN 間の BLOCKTIME（ DMCONFIG ファイルの DM_LOCAL_DOMAINS セクションの BLOCKTIME ）は、トランザクションタイムアウトとは別に監視されます。

/DOMAIN 機能を使用している場合、DMCONFIG の BLOCKTIME は、UBBCONFIG の BLOCKTIME や、トランザクションタイムアウトよりも大きな値を設定しないと、この BLOCKTIME が邪魔をしてトランザクションがむやみにロールバックされることになりかねません。

省略値は UBBCONFIG での BLOCKTIME の値と同じ値になりますが、DMCONFIG で明示的に BLOCKTIME を記述することをお勧めします。
●メッセージキューの滞留状況の確認方法

現在のプロセスごとのメッセージキューの滞留状況は、UNIX コマンド ipcs -qa で確認できます。

※ipcs -qa の実行例
$ ipcs -qa
IPC status from /dev/kmem as of Mon Aug 13 20:56:41 2001
T ID KEY MODE OWNER GROUP CREATOR CGROUP CBYTES QNUM QBYTES LSPID LRPID STIME RTIME CTIME
Message Queues:
q 851974 0x00000000 --rw-rw-rw- kashi tuxedo kashi tuxedo 726 2 32768 15447 14952 20:56:37 20:56:37 20:56:07

「 CBYTES 」が滞留バイト数、「 QNUM 」が滞留メッセージ数、「 QBYTES 」がメッセージキューサイズになります。
上記の例ではそれぞれ 726、2、32768 となっていることがわかります。ここで、QBYTES はカーネルパラメータの MSGMNB の値と同じになります。

どのサーバプロセスのメッセージキューかは、「 LRPID（取り出したプロセスのID）」と、ps コマンドで出力されるプロセス ID とをつき合わせて確認します。

1.ある１つの CBYTES が MSGMNB に近ければ、そのキューがあふれる可能性が高くなります。 

2.CBYTES の総数が MSGSEG×MSGSSZ に近ければ、OS 全体のメッセージ総バイト数がひっぱくしています。 

3.QNUM の総数が MSGTQL に近ければ、OS 全体のメッセージ数がひっぱくしています。

参考：メッセージ関連のカーネルパラメータの意味は、以下の通りです。
MSGMNB ・・・ 1 メッセージキューの最大容量
MSGMAX ・・・ 1 メッセージの最大長
MSGTQL ・・・ OS 全体で滞留できるメッセージ総数
MGSSEG×MSGSSZ ・・・ OS 全体で滞留できるメッセージ総容量
MGSMNI ・・・ OS 全体のメッセージキューの最大数


●MSSQ はサーバの増やしすぎに注意

Tuxedo は、サーバを多重化した場合に、MSSQ か SSSQ かのモデルに関係なく、各サーバに均等に要求を割り当てます。MSSQ モデルでは、ひとつのメッセージキューを共有するサーバの数に比例して、そのメッセージキューに対するアクセスが増加し、I/O 排他処理によるオーバヘッドが次第に大きくなります。
マシンスペックにも依りますが、MSSQ のサーバ数は、あまり多くしないほうがよいでしょう（だいたい10以下が普通）。

●メッセージキューがあふれる条件は？

Tuxedo では、ひとつのメッセージのデータサイズが、カーネルパラメータの MSGMAX 以上もしくはメッセージキューの最大容量（カーネルパラメータの MSGMNB ）の 75% 以上になると、永続記憶域のファイル I/O を使用したプロセス間通信に切り替わります。
プロセス間通信がファイル I/O により行われると処理性能が著しく低下するので、そのような状況は避けるべきです。

また、メッセージキューに滞留しているメッセージデータの総量が MSGMNB を超えてしまうと、後から来る要求メッセージはブロッキングされてしまいます。
メッセージキューに滞留するメッセージデータの総量をシステム設計時に見積もるには、待ち行列理論を利用します。プロセスに対する単位時間あたりの要求数を n 、平均サービス時間を T としたとき、プロセスの稼働率ρ= nT を用いて、待ち行列長さは ρ/(1-ρ) で表されることから、平均メッセージデータサイズを D とすると、滞留するデータ総量はおよそ Dρ/(1-ρ) となります。この値が MSGMNB を超えないようにある程度余裕度をもって設計してください。

また、一つ一つのメッセージキューがあふれていなくても、OS 全体のメッセージ総数やメッセージ総容量が、これらの最大値を制限するカーネルパラメータ （MSGTQL と MSGSSZ×MSGSEG） の値を超えた場合、同様にメッセージの送信はブロッキングされるので注意が必要です。

システム稼働時におけるメッセージの滞留状況を確認する方法については、こちらをご覧ください。

●HP-UX における MSGMNB の最大値について

HP-UX 11.0 以前のバージョンでは、MSGMNB の最大値は 64KB までとなっています。HP-UX の拡張パッチを適用することにより、この値を 64MB まで増やすことができるようになります（ HP-UX11i からはパッチ不要）。
PHKL_21039 、PHKL_21684 、PHKL_21778

上記 3 つのパッチは、64MB のメッセージキューに対応するために必要なパッチです。BEA Tuxedo V8.0J では、Tuxedo が持つライブラリが 64MB のキューを使用するように作成されていることから、上記のパッチが必須となっています。

上記パッチを適用すれば、kmtune コマンドを用いてカーネルパラメータ MSGMNB を最大 64MB まで設定することが可能になります。また、sam を用いてカーネルパラメータを調整する際には、さらに以下のパッチが必要になります。

PHCO_21187

※BEA Tuxedo V7.1J 以前のバージョン（HP-UX プラットフォーム）では、Tuxedo が持つライブラリが 64KB のキューを使用するように作成されていることから、OS レベルで 64MB のメッセージキューが使用可能になったとしても、Tuxedo で使用できるメッセージキューサイズは依然として最大 64KB であることに注意してください。

●/Qは重い？

/Q はファイル I/O が介入するため、複数のクライアントが /Q を同時に使用することがある場合は、その数だけ TMQUEUE サーバを起動してください。そうすることにより、/Q 要求を並列に処理することができるので、ファイル I/O のブロッキングによる処理の遅延を短くすることができます。

●優先度つきのサービス呼び出しについて

メッセージキュー内のメッセージは、10 回に 1 回は FIFO 方式に基づいて取り出されるため、優先順位の低いメッセージがキューにいつまでも残されることはありません。優先度の低いインターフェイスやサービスでは、特に応答時間を問題にする必要はありません。

●メッセージキューアクセスの競合と SPINCOUNT

あるサービスに対する要求が集中した場合、該当するサーバプロセスのメッセージキューに対する I/O 要求が集中するため、競合が発生しやすくなります。競合が発生すると、後からきた I/O 要求はブロックされ、SPINCOUNT 回数だけリトライした後、一定時間ウェイトするという動作を繰り返します。

デフォルトでは SPINCOUNT = 0 になっており、ブロックされると無条件にウェイトがかかってしまいます。もし、メッセージキューが滞留しており、サービスのスループットが低下するようであれば、SPINCOUNT を増やすことによって、一定時間のウェイトを平均的に少なくすることが可能になります。

ただし、あまりSPINCOUNTの値を大きくしすぎると、そのぶん多くのCPUリソースを必要とするので、かえってスループットが低下する可能性もあります。

より詳しい情報 >>ロック・スピンの回数を設定する（Oracleホームページ）

●Tuxedo が作成する IPC 資源の管理

Tuxedo は、UBBCONFIG の RESOURCES セクション内の IPCKEY の値とは関係なく、key = 0 の IPC 資源も作成します。もし IPC 資源を管理したいのであれば、ユーザーアカウント単位で管理する必要があります。

任意の IPC 資源について、その IPC 資源が Tuxedo ランタイムシステムが作成したものであるかどうかを判断するためには、Tuxedo 専用のユーザーアカウントを作成し、管理することをお勧めします。

上記のような管理方法は、Tuxedo が異常終了して IPC 資源のゴミが OS 上に残ってしまった場合に、それら IPC 資源を削除するときに有効な方法となります。

※Tuxedo V7.1J 以降では、tmipcrm(1) コマンドが用意されており、指定した TUXCONFIG ファイルを参照して、当該する IPC 資源を簡単に削除することが出来ます。

●サーバの自動再起動機能の動作について

RESTART = Y で再起動がかかるのは、（MAXGEN-1）回です。すなわち、RESTART = Y だけを指定しても、MAXGEN のデフォルト値が 1 なので、事実上再起動はされないままであることに注意してください。

もし、GRACE 時間内に（MAXGEN-1）回「再起動→異常終了」のシーケンスが繰り返されると、それ以降二度と自動再起動は行われません。
※ただし、tmboot コマンドを用いて手動で起動すれば、ふたたび自動再起動機能が有効になります。

また GRACE=0 に設定しますと、何回でも再起動されます。

●サーバ多重化時のサーバIDに注意

サーバを多重化する場合、多重化する数のぶんだけ、サーバ ID（ SRVID ）が割り振られます。

すなわち、SRVID = 100 のサーバを 10 多重化する場合は、100～109 の SRVID が使用されます。

既に 101～109 の範囲の SRVID を別のサーバで指定しているのであれば、それらのサーバの SRVID と重ならないようにコンフィギュレーションしてください。



●トランザクションのリトライは余裕を持って

Tuxedo では、グローバルトランザクションのエントリテーブルを内部的に所有しており、そのテーブルのエントリ数が MAXGTT を超えると、新しいトランザクションを開始できなくなります（ MAXGTT は、UBBCONFIG ファイルの RESOURCES セクションで設定できます）。

Tuxedo では、このトランザクションテーブルへのエントリは commit / rollback した瞬間ではなく、最大 SCANUNIT 時間のタイムラグの後に削除されます。したがって、トランザクションが rollback された後すぐに、そのトランザクションをリトライするような設計にしている場合、rollback の原因となった障害が解消されない間は、SCANUNIT 時間内でグローバルトランザクションテーブルへのエントリ数が際限なく増え続け、MAXGTT に引っかかるという可能性があります。

rollback 後からトランザクションの再発行までは、ある程度の時間間隔を設けたほうがよいでしょう。



●完全なシャットダウンはなかなか難しい

Tuxedo システムが正常に稼働しているときは、tmshutdown コマンドで綺麗にシャットダウン（ Tuxedo システムに関するプロセスおよび IPC 資源をすべて解放）することができますが、一つでもあるサーバがストールしている場合は、tmshutdown コマンドがストールし、さまざまなゴミが残ってしまう場合があります。

できるだけ安全に、かつ綺麗にシャットダウンするには、以下のような手順でシャットダウンします。
1.tmshutdown -y -s WSL ・・・ WSリスナ／ハンドラを先に落とします
2. tmshutdown -k TERM -y ・・・ 各サーバに SIGTERM を送信します
3. tmshutdown -k KILL -y ・・・ 各サーバに SIGKILL を送信します
4. tmadmin
　　 > bbc ・・・ 整合性を取ります
　　 > q ・・・ tmadmin を終了します
5. tmshutdown -y -c ・・・ BBL を停止します。

2) から 3) の間は５、６秒間隔を空けてください。より安全なシャットダウンのために、上記のような step - by - step のシャットダウンを、シェルスクリプトなどを用いて実現することが望ましいでしょう。

※ tmshutdown の -k オプションでは、 各サーバプロセスに対し、シグナル( SIGTERM もしくは SIGKILL）を送信しますが、BBL だけに対してはシグナル送付ではなく、メッセージキュー経由での電文送受信により、停止処理を行います。もし BBL がストールしてしまっていた場合、tmshutdown コマンドは BBL に対して SIGTERM ではなく、キューによるメッセージ送信を行おうとするので、tmshutdown コマンドが応答しなくなってしまいます。



●syslog にイベントを出力する

Tuxedo が syslog に Tuxedo システムイベントを出力するためには、環境変数 TMSYSLOGD_FACILITY（0 以上 7 以下の整数値）を設定した後、TMSYSEVT サーバプロセスを起動する必要があります。

TMSYSEVT サーバプロセスのエントリ定義例（ubbconfig ファイル内）を以下に示します。


*GROUPS
EVTGRP GRPNO=10000　OPENINFO=NONE

*SERVERS
DEFAULT　:　RESTART=Y　MAXGEN=10　REPLYQ=N　GRACE=60
TMSYSEVTSRVID=10000　SRVGRP="EVTGRP" #　プライマリサーバ
CLOPT="-A --"
TMSYSEVTSRVID=10001　SRVGRP="EVTGRP" #　セカンダリサーバ
CLOPT="-A -- -S -p 5"

TMSYSEVT で使用する syslog の facility は local ファシリティ 0 ～ 7 から選択可能です。すなわち、LOG_LOCAL0 から LOG_LOCAL7 までを選択できます。（環境変数 TMSYSLOGD_FACILITY の設定値の 0 ～ 7 は LOG_LOCAL0 から LOG_LOCAL7 に対応しています。）

このほかに syslogd 側の設定も必要になります。たとえば、/etc/syslog.conf に以下のように設定します。


--------------------------------
# @(#) $Revision: 74.1 $
#
# syslogd configuration file.
#
# See syslogd(1M) for information about the format of this file.
#
mail.debug /var/adm/syslog/mail.log
*.info;mail.none;local2.none /var/adm/syslog/syslog.log
*.alert /dev/console
*.alert root
*.emerg *
local2.debug /var/adm/syslog/syslog.log <---- ここ
-------------------------------

上記の例では、ファシリティ2（環境変数 TMSYSLOGD_FACILITY を 2 に設定）にデバッグレベルを指定し、出力先ファイルを /var/adm/syslog/syslog.log に設定しています。デバッグレベルに設定すると、すべてのシステムイベントが syslog に出力されるようになります。ERROR 系のみ出力したい ということであれば /etc/syslog.conf の Tuxedo 用 facility を以下のように修正して下さい。


local2.err /var/adm/syslog/syslog.log

なお、syslog.conf の書き方全般に関しては OS のマニュアルをご参照下さい。

/etc/syslog.conf 修正後は syslogd の動作に反映させるため、syslogd に /etc/syslog.confを再読み込みさせる必要があります。SIGHUP を syslogd に送ってください。


$ kill -HUP ${syslogdのプロセスID}

これで、syslog に Tuxedo のシステムイベントが出力されるようになります。
※ただし、OS（syslog）の制約ですが、日本語環境では使用できない（文字化けする）ことに注意してください。



●WSL の -N オプションの注意点 ― Nagle アルゴリズムによるネットワーク遅延

WSL の -N を使用した場合、-N オプションを使用していない場合と比較して、内部的に呼ばれる UNIX のシステムコールのシーケンスが変化します。

パターン A が、-N オプションあり、パターン B が、-N オプションなしに相当します。 (※実際のシーケンスと全く同じ処理ではありません。問題箇所を明確にするために、アレンジしています。)
クライアント側パターン A


ioctl() … FIOSNBIOセット
　 ↓
select() … SERVER 側から 1 回目のメッセージ受信を
　 ↓ 待ち合わせる。
recv() … 1 回目のメッセージ受信
　 ↓
ioctl() … FIOSNBIO 解除
　 ↓
recv() … 2 回目のメッセージ受信

クライアント側パターン B


ioctl() … FIOSNBIO セット
　 ↓
select() … SERVER 側から 1 回目のメッセージ受信を
　 ↓ 待ち合わせる。
recv() … 1 回目のメッセージ受信
　 ↓
★ send() … SERVER 側へメッセージ送信
　 ↓
ioctl() … FIOSNBIO 解除
　 ↓
recv() … 2 回目のメッセージ受信 


パターン A では、サーバ側から一方的にデータを送信する形になっているのに対して、パターン B では、★印の箇所でクライアント側からのデータ送信が挟まっている形になっています。ある条件下においては、パターン A でクライアントが 2 回目のメッセージ受信を開始するのが、パターン B に比べて 10 倍以上も遅くなることがあります。

これは、TCP の遅延送信 ( Nagle アルゴリズム) と遅延 ACK が関係してきます。

パターン A において、小さなサイズのデータを連続して send(2) (または write(2)) すると、TCP の遅延送信 ( Nagle アルゴリズム) により 2 回目に送信したデータは直ちに回線上には流れません。先に送信したデータに対する受信側 TCP からの ACK ( TCP レベルでの応答) を待ってから送信されます。
このため、送信側アプリケーションが連続して send(2) を 2 回実行したとしても、実際に 2 回目の send(2) 分のデータが回線に流れていくのは受信側 TCP からの ACK 待ち時間分だけ遅延します。

パターン B の動作では、送信側アプリケーションの動作は変わりませんが、受信側アプリケーションが 1 回目のデータを recv(2) した後に send(2) を 1 回実行しています。この send(2) のタイミングで遅延していた ACK が送信側 TCP に対して送信されるため、2 回目の send(2) 分のデータが直ちに送信されることになります。

ネットワークプログラミングの一般論として、小さいデータを連続して send(2) (write(2)) すると、遅延送信 ( Nagle アルゴリズム)と遅延 ACK の影響により、性能が劣化する、とお考えください。
# Nagle アルゴリズムや遅延 ACK の詳細に関しては TCP/IP の一般書籍を参照してください。

このような状況を回避するには、
1.送信側アプリケーションは、小さなデータをチマチマ送らずに、まとめて 1 回の send(2) で送信する。 
2.送信側アプリケーションで TCP_NODELAY オプションを有効にする。（ Tuxedo システム全体に影響） 
3.受信側 TCP の遅延 ACK 時間 (デフォルト 50ms) を短くする。（ OS レベルの変更なので同一マシンで動作する他の PP にも影響）

という方法があります。3. の方法は同一マシン上で正常に動作しているアプリケーションに対しても影響を及ぼす恐れがあるばかりか、ネットワークの輻輳などの思わぬ弊害が生じる可能性もありますので、十分に注意する必要があります。極力 1. の方法（アプリケーションの修正）で解決してください。

※なお HP-UX では 遅延 ACK 時間は tcp_deferred_ack_interval というカーネルパラメータで調整可能ですが、このパラメータはサポート外となっています。



●RM（リソース・マネージャ）の使い方

Tuxedo で分散トランザクションを実現するために RM の XA インターフェースを利用するには、さまざまな準備が必要になります。
以下では、RM として Oracle 9.0.1 を使用した例を挙げます。
1.RM 定義ファイルに、RM 用にリンクするライブラリを記述する
${TUXDIR}/udataobj ディレクトリ配下にある RM ファイルに、以下のような記述を追加します。


RM名:xaosw:-L${ORACLE_HOME}/lib32 -lclntsh


ここで、


第一フィールド　→　任意
第二フィールド　→　xaosw は、Tuxedo と Oracle の I/F の構造体であり固定。
第三フィールド　→　リンクする RM のライブラリ


を示しています。例えば、RM 名を OraXA とした場合、${TUXDIR}/udataobj/RM ファイルの中には、


OraXA:xaosw:-L${ORACLE_HOME}/lib32 -lclntsh


と記述します。ここで、-lclntsh は Oracle のクライアント用 shared ライブラリを表します。
（ Oracle8i 以降では、-lcltsh を指定するだけで必要なライブラリをリンクできるようになりました。Oracle8 以前のバージョンにおいては、必要なライブラリをそれぞれ明示的に指定してリンクする必要があります。詳しくは、Oracle 担当部門にお問い合わせください。）
2.buildserver 実行時に -r オプションで RM 名を指定する
RM を利用するサーバアプリケーションをビルド( buildserver )するときに、-r オプションで RM 名を指定します。上記の例では、OraXA を指定することにより、リンカに Oracle のライブラリを渡します。


$ buildserver -r OraXA -f oraserver.c -o oraserver
3.Tuxedo の TM サーバプロセスである TMS (Transaction Manage Server)を Oracle 用に作成する
Tuxedo がグローバルトランザクションを制御するために、Oracle 用の TMS を別途作成する必要があります。


$ buildtms -r OraXA -o TMS_ORA9i

-r オプションで指定するのは、RM ファイルに指定した RM 名です。新しく作成する TMS の名前（ -o オプションの後に指定）は自由です。
4.UBBCONFIG の GROUPS セクションを設定する
UBBCONFIG ファイルの GROUPS セクションに、（3）で作成した TMS 名と、XA インターフェースの OPENINFO を記述します。


dbgroup GRPNO=1030
TMSNAME = TMS_ORA9i
TMSCOUNT = 3
OPENINFO = "OraXA:Oracle_XA+Acc=P/scott/tiger+SesTm=30+LogDir=/tux/oralog+SqlNet=fortuxedo"

GRPNO

サーバグループ番号

TMSNAME （3）で作成したTMS名 
TMSCOUNT 並列で起動するTMS数 （同時実行トランザクション数により多重度を変更します。
現実的には、総合評価の段階でトランザクションの負荷をかけ、tmadmin/pqでTMSのキューにトランザクションが滞留しない程度を目安とします。ほとんどの場合、デフォルトの3で十分です。） 
OPENINFO OraXA RM ファイルで指定した RM 名
 
Oracle_XA 固定
 
Acc Oracle に接続する時のユーザ/パスワード
 
 ※Tuxedo7.1J 以降では、ログインユーザーのパスワード部分に"*****"(5つの連続したアスタリスク)を記述することにより、tmloadcf 時にパスワードを入力するようになります。プレーンテキストでパスワードを記述する必要がなくなるので、セキュリティが向上します。
(例) Acc=P/scott/***** 
SesTm Orace のセッションタイムアウト
（ xa_end から次の xa_start / xa_commit / xa_rollback を受け取るまでの Oracle 側での監視タイマ）
 
LogDir XA トレース（ SQL*Net クライアントが出力する）の出力先ディレクトリ

 
SqlNet SQL*Net 接続する場合に tnsnames.ora で指定するサービス名
 
5.分散トランザクション用の動的な情報を保持するテーブルに対するアクセス権を設定する
OPENINFO の Acc で指定するユーザが、Oracle 内にある分散トランザクション用の動的テーブルにアクセスできるようにします。通常は ${ORACLE_HOME}/rdbms/admin 配下の xaview.sql を実行してください。
6.SQL*Net を設定する（SQL*Net 使用時）
Oracle を利用する Tuxedo サーバアプリケーションと、Oracle が稼働しているノードが異なる場合は、SQL*Net 接続になるため、SQL*Net を設定する必要があります。以下のファイルの内容を、適切に変更し、SQL*Net が利用できるようにしてください。 Tuxedo 側ノード　…　tnsnames.ora 
Oracle 側ノード　…　listener.ora

なお、Oracle 側の設定や、Oracle のバージョンによる XA インターフェースの違いは、Oracle 担当部門にお問い合わせください。



 



●ファイアウォールを越えて /WS クライアントが接続するには？

ファイアウォールをまたがった /WS 接続では、一般的に以下の２点を考慮する必要があります。
NAT の使用 
ポートフィルタリングの使用

まず、WSL/WSH プロセスの基本的な役割を理解しましょう。 /WS クライアントは、以下のシーケンスでサーバノードとの通信を確立します。
1./WS クライアントを起動するシェル環境変数の WSNADDR に設定されているアドレス宛に、WSL プロセスへの接続を試みます。 
2.WSL プロセスから、接続すべき WSH プロセスの IP アドレスおよびポート番号を受け取ります。 
3.WSL プロセスとの接続を /WS クライアント側から切断します。 
4.2. の手順で通知されたアドレス宛に、WSH プロセスとの接続を試みます。

WSH（WorkStation Handler）プロセスとは、WSL（WorkStation Listener）プロセスから生成される子プロセスで、/WS クライアントとの実際のメッセージ通信を担います。すなわち、WSL プロセスの役割は、/WS クライアントからの接続要求を WSH プロセスへとディスパッチするだけです。WSH プロセスは Tuxedo のネイティブクライアントとして動作し、/WS クライアントからの要求を各サーバプロセスに転送します。

■NAT の使用

上記接続シーケンスの 2. の手順で通知される WSH の IP アドレスは、デフォルトでは WSL が動作するノードのプライベートアドレスになります。ここで、/WS クライアントが動作するノードと、WSL/WSH が動作するノード間において NAT を使用している場合、通知された IP アドレスを用いて WSH へと接続することができません。WSH への接続でエラーとなると、ULOG には以下のようなメッセージが出力されます。


LIBWSC_CAT:1064: ERROR:Unable to establish WSH connection 0x000209a6c0a80001

※上記エラーメッセージの最後に出力されている文字列は、以下のように解釈します

"0x" 16進数であることを示します（固定） 
"0002" TCP/IP ファミリであることを示します（固定） 
"09a6" ポート番号を示します（16 進数 4 ケタ） 
"c0a80001" 接続を試みようとした IP アドレス（16 進数 8 ケタ） 

たとえば WSL が動作するノードのプライベート IP アドレスが 192.168.0.3、外部 IP アドレスが 10.1.2.3 であり、WSL がリスンするポート番号が 9999 である場合、ubbconfig 内 WSL サーバエントリの CLOPT 文字列に -H オプションを指定し、通知する WSH プロセスへの接続用外部アドレスを下記のように指定します。


*SERVERS
WSL　　　CLOPT="-A -- -n //192.168.0.3:9999-H //10.1.2.3:MMMM"

ここで、-H オプションに指定した "MMMM" の文字列はワイルドカードを表します。この部分にポート番号を記述することもできますが、完全に無視されます。（何も記述しないとエラーになります）





■ポートフィルタリングの使用

ファイアウォールでポートフィルタリングを行っている場合、WSH プロセスがリスンするポート番号や、/WS クライアントがバインドするポート番号を限定する必要がある場合があります。WSH プロセスがリスンするポート番号を限定するには、ubbconfig 内 WSL サーバエントリの CLOPT 文字列に -p および -P オプションを記述し、それぞれ WSH が使用するポート番号の最小値と最大値を指定します。以下の例では、WSH が使用するポート番号を 8800 番から 8899 番に限定しています。（同じ値にすることにより、WSH が使用するポート番号をひとつに限定することもできます）


*SERVERS
WSL　　　CLOPT="-A -- -n //192.168.0.3:9999 -H //10.1.2.3:MMMM　?
　　　　　-p 8800 -P 8899"

ここで注意しなければならないのは、WSH を起動する数です。WSH プロセス１つにつき１つのポートを使用するので、WSH が使用するポートの範囲を上記のように 100 個に制限した場合、この論理マシン上で起動できる WSH プロセスの総数は 100 個までとなります。（101 個目の起動時にエラーとなります）

また、Tuxedo V7.1J 以降であれば、/WS クライアント側でバインドする IP アドレスおよびポート番号を限定することができます。/WS クライアント側でバインドする IP アドレスおよびポート番号を限定するには、/WS クライアントを実行するノードで WSFADDR 環境変数および WSFRANGE 環境変数を設定した後、/WS クライアントを実行します。/WS クライアントでバインドしたい IP アドレスを 10.1.2.4 、ポート番号を 9999 としたい場合、以下のように各環境変数を設定します。 


(csh の場合)
$ setenv WSFADDR //10.1.2.4:9999
$ setenv WSFRANGE 1

/WS クライアントも WSH と同様、１プロセスあたり１ポートを使用するので、上記のように設定した場合、同じ環境からは /WS クライアントを１つしか起動できません。

また、「ファイアウォール越え」という理由だけでなく、他 PP が使用しているポートとのバッティングを回避するためにも、使用ポートを制限するようにシステムを設計し、コンフィギュレーションすることをお勧めします。



●ULOG に出力されるメッセージを運用管理製品から監視するには？

Tuxedo の ULOG ファイルのファイル名には、ULOGPFX で指定した文字列（指定しない場合、デフォルトは ${APPDIR}/ULOG ）の後ろに日付をサフィックスとした文字列が、ファイル名のフルパスとして使用されるので、日付が変わるたびに新しい ULOG ファイルが生成されることになります。しかしほとんどの運用管理製品では、メッセージ監視対象のログファイル名には固定の文字列しか使用できないので、ULOG ファイルに出力されるメッセージを継続して監視することができません。

Tuxedo は、新しい ULOG ファイルを作成するときに、新しく使用したいファイル名と同じ名前のファイルが既に存在する場合は、新しいメッセージを既存ファイルの末尾にアペンドします。この特性を利用し、以下のようにあらかじめ固定ファイルにシンボリックリンクを張っておくことにより、ひとつの監視対象ログファイルに対して、日付をまたがった ULOG メッセージ出力が可能になります。

ただし Tuxedo の ULOG メッセージには日付が出力されませんので、ご注意ください。


（例）
$ ln -s /var/log/tuxulog.log ${APPDIR}/ULOG.043004
　　　　　　　　　　　　　　　　　　　 ↑ 2004年 4月30日に出力されるメッセージ用
$ ln -s /var/log/tuxulog.log ${APPDIR}/ULOG.050104
　　　　　　　　　　　　　　　　　　　 ↑ 2004年 5月 1日に出力されるメッセージ用
$ ln -s /var/log/tuxulog.log ${APPDIR}/ULOG.050204
　　　　　　　　　　　　　　　　　　　 ↑ 2004年 5月 2日に出力されるメッセージ用
　　　 ：
　　　 ：

###############################################################################
●Tuxedo ご注意事項

●BEA Tuxedo V8.1J インストール時の注意点

(1)HP-UX
 Tuxedo V8.1J を HP-UX において、日本語環境で使用したい場合は、日本語 SJIS （ja_JP.SJIS）環境でインストールする必要があります。日本語 EUC （ja_JP.eucJP）環境でインストールしようとすると、「マルチバイト文字が正しくありません」というエラーメッセージが現れインストールに失敗します。詳しくは FAQ ＜テクニカル編＞Tuxedo8.1 を HP-UX プラットフォームにおいて、日本語 EUC 環境（ja_JP.eucJP）で インストールしようとすると「マルチバイト文字が正しくありません」というエラーメッセージが 出力され、インストールに失敗します。 をご覧ください。

(2)Solaris
 Tuxedo V8.1J を Solaris において日本語環境（ja）でインストールする際は、環境変数 PATH の先頭に /usr/ucb を追加してください。 /usr/ucb がパスの先頭にないと「Invocation of this Java Application has caused an InvocationTargetException. This application will now exit.」というエラーメッセージが発生して、インストールに失敗します。詳しくは FAQ ＜テクニカル編＞Tuxedo8.1 を Solaris プラットフォームにおいて日本語環境で（ja）でインストールしようとすると「Invocation of this Java Application has caused an InvocationTargetException. This application will now exit. 」というメッセージが出力され、インストールに失敗します。 をご覧ください。

(3)Windows
 Tuxedo V8.1J を Windows でサイレント・インストールする際、installer.properties ファイルに BEAHOMES_NEW の項目を必ず記述してください。 BEAHOMES_NEW を記述せずにインストールしますと、パッチを当てる際にエラーが発生しパッチのインストールに失敗します。詳しくは FAQ ＜テクニカル編＞Windows において Tuxedo8.1 にパッチをインストールすることができません。をご覧ください。

(4)HP-UX ・ Solaris ・ Windows 共通
Tuxedo V8.1J を HP-UX・Solaris・Windows にサイレントモードでインストールすると、USER_LOCALE に ja または ja_JP を指定しても、日本語メッセージカタログがインストールされません。詳しくは FAQ＜テクニカル編＞Tuxedo8.1で、サイレントインストール時に、USER_LOCALE に ja または ja_JP を指定しても日本語メッセージカタログがインストールされませんをご覧ください。

●BEA Tuxedo V8.1Jの Windowsクライアントでのご利用について

BEA Tuxedo V8.1Jを Windowsクライアントでご利用になる場合、パッチの適用が必須となります。プログラムインストール時に、合わせてパッチを適用してください。

当該パッチは、BEA Tuxedo の最新パッチがほしいのですが、どうすれば入手できますか？の要領に従ってe-mailでご請求下さい。

●BEA Jolt V1.2Jのメッセージ・カタログについて

Jolt V1.2J において、Jolt V1.1J の自動コード変換機能を使用している場合、 自動コード変換に関するエラーのメッセージ・カタログ（LIBJCONV.text および LIBJCONV_CAT）を入手し、適切なディレクトリにコピーする必要があります。 このメッセージ・カタログが存在しないと、自動コード変換機能に関するエラーが発生した場合に、エラーメッセージが正常にログに出力されません。

このメッセージ・カタログファイルは、Jolt V1.2J ユーザ様向けに提供させていただいているJolt V1.1J 自動コード変換パッケージには含まれておらず、 Jolt V1.1J をご購入でないお客様においては、別途入手していただく必要があります。自動コード変換機能向けのメッセージ・カタログをご所望の場合は、e-mailにて下記アドレスまでご請求ください。

メッセージ・カタログ請求先：tuxedo@bea.jp.nec.com 　

●BEA Tuxedo V6.3J／BEA Jolt V1.1Jのサポート終了について

以下の製品はサポート停止となりました


　

受注停止

サポート終了

BEA Tuxedo V6.3J 2003年10月31日 2003年11月30日 
BEA Tuxedo V6.4J 2006年 1月31日 2006年 1月31日 
BEA Jolt V1.1J 2001年7月31日 2003年11月30日 

●BEA Tuxedo V8.1J の Windows Server 2003 における制限事項について

Win32API の CreateProcess() の非互換により、Windows Server 2003 で BBL がアプリケーションプロセスダウンを検出できないという問題が存在します。この問題を回避するためには、Tuxedo V8.1J の Rolling Patch 64 番以降のパッチを適用する必要があります。パッチの入手方法についてはこちらをご覧ください。

●BEA Tuxedo V7.1J以降 の /WS クライアントを使用する場合のライセンスファイルについて

Tuxedo V7.1 以降では LLE（リンクレベルの暗号化）機能が加わったため、/WS クライアントマシン上でもライセンスファイルのチェックロジックが加わりました。

Tuxedo V7.1 以降のバージョンでは、/WS クライアント側においても、LLE 機能を使用するときにはライセンスファイルが必要になります。

LLE 機能を使用しないのであれば、/WSクライアントのみを使用するマシン（TUXEDOサーバを起動しないマシン）には、ライセンスファイルを配置する必然性はありませんが、ライセンスファイルが配置されていない状態で /WS クライアントを起動すると、下記のようなエラーメッセージが ulOG に出力されます。


GP_CAT:1561 ERROR: Problem with license file$TUXDIR/udataobj/lic.txt.

上記メッセージが出力されても、LLE 機能を使用していなければ、動作的にもライセンスポリシー的にも全く問題ありません。

メッセージ出力を抑止したい場合は、空の lic.txt ファイルを ${TUXDIR}/udataobj ディレクトリに配置してください。（空の lic.txt ファイルを配置した場合には、LLE 機能は使用できません）

●Tuxedo V9.1J(32bit版, 64bit版)の Red Hat Enterprise Linux 5 へのインストール時の注意点

 

BEA Tuxedo V9.1J(32bit版, 64bit版)を Red Hat Enterprise Linux 5 でインストールする際は、インストーラの書き換えを行ってください。インストーラを書き換えずに起動しますと、エラーが発生し、インストールに失敗します。

具体的には、


cat tuxedo91_32_SLES_9_x86.bin | sed "s/export LD_ASSUME_KERNEL/#xport LD_ASSUME_KERNEL/"

のように、export LD_ASSUME_KERNEL の行をコメントアウトしてください。

※念のためインストーラファイルのバックアップを取って書き換え作業をお願いします。

●Tuxedo 10.0, 10gR3インストール時の注意点

Tuxedo ではインストール時にインストールセット（インストールするコンポーネントの組み合わせ）を選択しますが、Tuxedo 10.0, 10gR3においては一部のインストールセット選択時に正しくインストールが行われない問題がございます。

該当するプラットフォームは以下となります。
HP-UX
Red Hat Linux
Sun Microsystems Solaris /li>

Windowsプラットフォームは該当いたしません。

以下はインストールセットの選択画面です。（コンソール モード インストールの場合。）
===============================================================================
インストール・セットの選択
-------------

このインストーラでインストールするインストール セットを選択してください。

->1- 完全インストール
2- サーバのインストール
3- 完全クライアント・インストール
4- Jolt クライアントのインストール
5- ATMI クライアントのインストール
6- CORBA クライアントのインストール

7- カスタマイズ...

インストール セットの番号を入力するか、デフォルトを使用する場合は キーを押してください。
:

===============================================================================


上記のうち、Tuxedo 10.0, 10gR3で正しくインストールが行われないインストールセットは以下の３つです。
4- Jolt クライアントのインストール
6- CORBA クライアントのインストール
7- カスタマイズ...


正常にインストールするためには以下の５つの中からインストールセットを選択してください。
1- 完全インストール
2- サーバのインストール
3- 完全クライアント・インストール
5- ATMI クライアントのインストール
（Windowsのみ）.NET クライアント インストール セット

【参考】Tuxedo 10.0のインストールセット
###############################################################################
●Tuxedo FAQ＜テクニカル編＞

●Tuxedo システムの運用および管理に関する質問
1.障害が発生しました。問い合わせに必要な情報は何ですか？
2.現在のパッチレベルはどのようにして確認できますか？
3.BEA Tuxedo の最新パッチがほしいのですが、どうすれば入手できますか？
4.アンインストールの後にいくつかのファイルが削除されませんでした。
5./var/tmp 配下に、Tuxedo 実行ユーザ名でファイルが作成されています。Tuxedo がここにファイルを作成することがあるのでしょうか？
6.Tuxedo で発生したイベントを syslog に出力できますか？
7.あるサービスがストールしてしまいました。Tuxedo システム全体を安全にシャットダウンするにはどうすればよいのでしょうか？
8.tmloadcf コマンドの -c オプションで表示される IPC 資源の値は何を示しているのですか？
9.tmboot（tmshutdown）や tmloadcf（dmloadcf）で、y/n の確認に対して入力が受け付けられません。
10.tmshutdown コマンドは同時に複数動作させることができますか？
11.tmboot を迅速に行いたいのですが、何か方法はありますか？
12.tmconfig コマンドを用いてシステム構成を動的に変更した場合、Tuxedo を再起動してもその変更は反映されますか？
13.会話型サーバが自動起動された場合、サーバ数が増えたままで減りません。
14./Domain 使用時、UBBCONFIG ファイルを変更して tmloadcf を行った際に、dmloadcf もやり直す必要がありますか？
15.APPDIR ディレクトリに、good.XXXX というファイルが作成されています。これは何なのですか？
16.自動再起動機能を有効にしているサーバがダウンしましたが、すぐに再起動されません。なぜですか？
17.自動再起動機能を有効にしているサーバがダウンしましたが、restartsrvが「LIBTUX_CAT:577:ERROR: 他プロセスがこのスロットを所有しているので登録できません。」とメッセージが出て再起動しません。
18.Tuxedo8.1 を Solaris プラットフォームにおいて日本語環境で（ja）でインストールしようとすると「Invocation of this Java Application has caused an InvocationTargetException. This application will now exit. 」というメッセージが出力され、インストールに失敗します。
19.Tuxedo8.1 を HP-UX プラットフォームにおいて、日本語 EUC 環境（ja_JP.eucJP）で インストールしようとすると「マルチバイト文字が正しくありません」というエラーメッセージが 出力され、インストールに失敗します。
20.Tuxedo8.1で、サイレントインストール時に、USER_LOCALE に ja または ja_JP を指定しても日本語メッセージカタログがインストールされません
21.Windows において Tuxedo8.1 にパッチをインストールすることができません。
22.ラージファイルのファイルシステムを使用可能にしているのに、Tuxedo が出力を行うファイルが 2G バイトを超えるとファイルへの出力が行われません。
23.Windows のコントロールパネルから BEA Administration を起動させた際に見る事が出来る IPC Resources の各パラメータの意味を教えてください。
24.「NLS:4: Cannot open message catalog ○○○_CAT」というメッセージが表示されますが、このメッセージはどういう意味ですか？
25.tmadmin コマンドを実行すると、「TMADMIN_CAT:199: WARN: 管理者になることができません。Limited set of commands available.」というメッセージが表示されます。
26.Tuxedo インストール時にライセンスファイルもインストールを行おうとした所、「ライセンス・コンフィギュレーション・エラー」が発生します。
27.Tuxedoが、32bit用か64bit用かは、どうやって確認できますか？

●MP 構成に関する質問
1.マイグレーション機能を使用したいのですが、自動的に行ってはくれないのですか？
2.スレーブノードにも WSL/WSH プロセスを起動することはできますか？
3.最大何台のマシンを MP 構成で管理することができますか？

●/WS に関する質問
1.複数の WSL を起動している場合に、/WS クライアントがある WSL への接続を失敗したときに、自動的に他の WSL に接続させるようにするにはどうすればよいのでしょうか？
2.WSL のメッセージ圧縮機能を設定した場合、クライアントからのメッセージも圧縮されるのですか？
3.WSL の -T オプションと -N オプションとの違いは何ですか？
4.WSH のプロセス数は MAXWSCLIENTS に計上されますか？
5.ファイアウォールを越えて /WS クライアントが接続しようとすると、tpinit が TPESYSTEM でエラーリターンし、接続ができません。
6.TCP の KEEPALIVE 機能は /WS 構成時の WSクライアント-サーバ間にも適用されているのですか？
7.WSH のメモリサイズが大きく増加しています。メモリリークでしょうか？

●その他の機能に関する質問
1.ドメイン間のネットワーク障害を検出する機能はありますか？
2.トランザクションの伝播回数に制限はあるのでしょうか？
3./Q の再試行機能はトランザクションモードでなくても使用可能でしょうか？
4.TRANTIME の値と、tpbegin() に指定するタイムアウト時間の値は何が違うのですか？
5.トランザクションを開始（ tpbegin ）したイニシエータが、会話型処理が完了する前に tpcommit() を行うとどうなるのでしょうか？
6.tpbegin() から tpcommit() 間で何らかの障害を検出した場合、tpabort() をコールする必要がありますか？
7.TP-Tux 、TP-TUX 、PCTUX と組み合わせて使用できますか？
8.異なるバージョンの BEA Tuxedo 間で接続することはできますか？
9.Tuxedo のアプリケーションでシグナルを使用できますか？
10.Tuxedo アプリケーションのシグナルハンドラ中で ATMI を使用できますか？
11.Tuxedo で送受信可能なメッセージのサイズは最大何バイトですか？
12.クライアントアプリケーションが出力する Tuxedo メッセージを日本語化するにはどうすればよいのでしょうか？
13.Windows 版 BEA Tuxedo と Visual C++ バージョンの関係はどうなっていますか？
14.Tuxedo サーバまたはクライアントアプリケーション （Tuxedo コマンド含む） 実行時に "/usr/lib/dld.sl: Can't open shared library" と表示され、実行できません。
15.DOMAIN構成において、GWTDOMAINプロセスが「LIBGW_CAT:1029 ERROR:サービス要求がエラー "TPESVCERR - 要求を処理中にサーバでエラーがありました。"のためリモートサイトに転送されません。」 と表示され、電文の送信に失敗します。
16.Q_CAT:1447 が頻繁に出力されます。
17.tmboot しようとしたところ、ULOG に 「LIBTUX_CAT:296: ERROR: _tlog_open: _gp_tblopen: VTOC が初期化されていません。」が出力され、立ち上げに失敗します。
18.サーバの多重度をあげているにも関わらず、性能が思う様に出ません。


●【Tuxedo システムの運用および管理に関する質問】

障害が発生しました。問い合わせに必要な情報は何ですか？

障害発生時はまず ULOG ファイルを開き、障害が発生した時間の出力メッセージを確認します。
エラーメッセージの意味については、エラーメッセージに強くなるを参照してください。さらに、本 FAQ をよく調べ、当該する事象がないかどうか確認してください。

エラーメッセージの意味や FAQ を調査しても障害の原因や復旧方法がわからない場合は、障害発生時点における以下の情報のうち、収集できるものはできるだけ収集し、それらの情報とともにtuxedo@bea.jp.nec.comまでお問い合わせください。
マシン構成（できるだけ詳しく）
再現性
カーネルパラメータ一覧
構成記述ファイル（UBBCONFIG ファイル）
ULOG ファイル ( かつ TMTRACE を含んだファイル )
ipcs -a の結果
ps -efl コマンドの出力結果
core があればその解析結果
システムログ ( syslog.log など )

詳細な障害解析手順については、「問題解決資料収集手順」をご覧ください。



現在のパッチレベルはどのようにして確認できますか？

${TUXDIR}/udataobj ディレクトリ配下にある patchlev （JOLT コンポーネントは joltpatchlev）ファイルの中に、これまでに適用したパッチの一覧が表示されています。
 一番下の行の一番左に表示されている番号が現在のパッチレベルになります。

また バージョン8.0以降は以下のように tmadmin コマンドで表示されます。

※tmadmin -v の実行例


$ tmadmin -v

 INFO: BEA Tuxedo, Version 8.1, 32-bit,Patch Level 010
 INFO: Serial #: XXXXXXXXX-XXXXXXXXXX, Maxusers 100
 INFO: Licensed to: BEA Japan
 INFO: 56-bit Encryption Package

BEA Tuxedo の最新パッチがほしいのですが、どうすれば入手できますか？

以下の情報をお書き添えの上、tuxedo@bea.jp.nec.comへと要求を出していただければ、保守契約済みであることを確認後、最新パッチをご提供いたします。
Tuxedo バージョン
Tuxedoの保守契約番号
OS 名、バージョン
/WS クライアント or フルインストール
エンドユーザ名、システム名



アンインストール後にいくつかのファイルが削除されませんでした。

ソフトウェアのインストール後に新たに作成されたファイルはアンインストールしても残ります。また、一部不具合により、デフォルトで配置されたファイルも削除されずに残ってしまう場合もあります。特に問題はありませんので、お手数ですが手作業で削除してください。



/var/tmp 配下に、Tuxedo 実行ユーザ名でファイルが作成されています。Tuxedo がここにファイルを作成することがあるのでしょうか？

Tuxedo がファイル転送による通信を使用するときに、 /var/tmp に通信用ファイルが作成されます。
このファイルを受信する先が正常に動作すればこれを消去しますが、不意にダウンした場合には削除されず残ってしまいます。

※BEA Tuxedo V6.5J 以前のバージョンでは、これらのファイルの出力先は変更することができません。また、作成されるファイル名は Tuxedo として特定できる名称になっていませんので、注意してください。
 （ Windows 版 BEA Tuxedo の場合は、Tuxedo 起動ドライブのルートディレクトリ下に作成されます。）

※BEA Tuxedo V7.1J 以降のバージョンでは、環境変数 TMPDIR を指定することによって、一時ファイルの出力先を指定することができます。また、作成されるファイル名は "TUX" が頭に付くので、Tuxedo が作成したものであるかどうか判断することができるようになっています。

これらのファイルが大量に生成されるような場合、取り扱う電文サイズと比較して、メッセージキューのサイズが全体的に不足しています。詳しくは、メッセージキューがあふれる条件は？を参照してください。



Tuxedo で発生したイベントを syslog に出力できますか？

環境変数 TMSYSLOGD_FACILITY を設定することで可能です。
 詳しくは、syslog にイベントを出力するを参照してください。



あるサービスがストールしてしまいました。Tuxedo システム全体を安全にシャットダウンするにはどうすればよいでしょうか？

あるサービスがストールしてしまったために tmshutdown コマンドが応答しなくなってしまうと、Tuxedo プロセスや IPC 資源のゴミが残ってしまう可能性があります。
 詳しくは、完全なシャットダウンはなかなか難しいを参照してください。



tmloadcf コマンドの -c オプションで表示される IPC 資源の値は何を示しているのですか？

現在の構成で最低限必要とされる IPC 資源の目安を示しています。
しかし、システムの利用状況によっては、この値では不足する恐れがあります。

カーネルパラメータは、本番環境で十分にテストし、調整する必要があります。
なお、メッセージ関連の資源については以下の条件を満たすよう調整することをお勧めします。 


HP-UX
MSGSSZ * MSGSEG >> MSGMNB 

Windows
TUXIPC_MSG_SEG_BYTES * TUXIPC_MSG_SEGS >> TUXIPC_MSG_QUEUE_BYTES 

UX/4800
MSGSSZ >> MSGMNB 


tmboot (tmshutdown) やtmloadcf ( dmloadcf ) で、y/n の確認に対して入力が受け付けられません。なぜですか？

この現象は、日本語 HP-UX 環境で発生します。

この問題を回避にするには、いくつかの方法が存在します。 詳しくは、日本語 HP-UX 環境において、y/n の入力を有効にするをご覧ください。



tmshutdown コマンドは同時に複数動作させることができますか？

tmshutdown コマンドが同時に動作可能なのは１つのみです。



tmboot を迅速に行いたいのですが、なにか方法はありますか？

以下の方法が考えられます。
1.tmboot -w -y
 ⇒ 各プロセスを非同期で起動します。
よって正常に動作されているかの確認は行いません。
2.tmboot -M -y → tmboot -g xxxx -y &
 ⇒ tmboot -M -y で BBL を起動した後、-g オプションを指定して、
グループ毎にバックグラウンドで同時に起動します。



tmconfig コマンドを用いてシステム構成を動的に変更した場合、Tuxedo を再起動してもその変更は反映されますか？

バイナリファイル tuxconfig に変更が保存されるので、変更後再起動してもその変更は反映されます。

ただし、あらためてテキストファイルの形で保存したいのであれば、変更後に tmunloadcf コマンドを実行する必要があります。



会話型サーバが自動起動された場合、サーバ数が増えたままで減りません。

Tuxedo によって自動起動された会話型サーバプロセスは、自動的に減ることはありません。



/Domain 使用時、UBBCONFIG ファイルを変更して tmloadcf を行った際に、dmloadcf もやり直す必要がありますか？

dmloadcf コマンドは、一部 tuxconfig ファイルの情報を使用する部分が存在するので、dmloadcf もやり直す必要があります。

具体的には、DMCONFIG ファイル内の BROCKTIME パラメータは、DMCONFIG ファイル内で明示的に指定されない場合は tuxconfig ファイルの BROCKTIME の値を用います。暗黙的にそのような指定を期待している場合は、tuxconfig の内容を変更した後に、dmloadcf を行うことを忘れないでください。

ただ、これら UBBCONFIG および DMCONFIG それぞれの BROCKTIME は、トランザクションの際の挙動が異なります。詳しくは「BROCKTIME には２種類ある」を参照してください。



APPDIRディレクトリに、good.XXXXというファイルが作成されています。これは何なのですか？

本ファイルは TMSYSEVT と TMUSREVT が作成するファイルです。本ファイルには、登録されているイベントの一覧が出力されます。
 登録したイベントが不正であれば bad.${PID} というファイル名に記録が残ります。

本ファイルは、 tmshutdown で正常に停止された場合は自動的に削除されます。
ただし tmshutdown -k KILL などで TMSYSEVT や TMUSEREVT を強制終了した場合は、これらのファイルが残ってしまいます。

ただ、もしこれらのファイルが残っていても、TMSYSEVT や TMUSREVT が再起動された場合は、再度新たなファイルを作成するので特に問題はありません。
もし気になるのであれば、TMSYSEVT や TMUSREVT が起動していなければ、削除しても問題ありません。



自動再起動機能を有効にしているサーバがダウンしましたが、すぐに再起動されません。なぜですか？

サーバの自動再起動機能は、最大 SCANUNIT * SANITYSCAN 時間（デフォルトで120 秒）のタイムラグが発生します。

UBBCONFIG ファイルの RESOURCES セクションを確認してください。



自動再起動機能を有効にしているサーバがダウンしましたが、restartsrvが「LIBTUX_CAT:577:ERROR: 他プロセスがこのスロットを所有しているので登録できません。」とメッセージが出て再起動しません。

このメッセージは 複数のサーバプロセスを同時に自動再起動する際に表示され、１度に複数のサーバプロセスを再起動できないことを意味しています。

Tuxedo サーバプロセスの生死チェックは SANITYSCAN×SCANUNIT の間隔でおこなわれ、停止しているプロセスは再起動を行います。しかし、２つ以上のサーバが停止していた場合、ひとつめのサーバの再起動は成功しますが、ふたつめ以降のサーバを再起動しようとするたびに、LIBTUX_CAT:577 が出力され、再起動には失敗します。（どのサーバが最初に再起動されるかは規則性はありません）

以降、SANITYSCAN×SCANUNIT の間隔の生死チェックのタイミングで、停止している残りのサーバの再起動が順次行われることになります。

本動作による再起動の失敗は、MAXGEN パラメータで指定する再起動回数の制限には関係しません。



Tuxedo8.1 を Solaris プラットフォームにおいて日本語環境 (ja)でインストールしようとすると 「Invocation of this Java Application has caused an InvocationTargetException. This application will now exit. 」 というメッセージが出力され、インストールに失敗します。

環境変数 PATH の先頭に /usr/ucb を追加してください。

これは既知の問題（CR092682）として以下のページに書かれています。
http://otndnld.oracle.co.jp/document/products/tuxedo/tux81/relnotes/relnotea.htm#389189
関連項目 ＜ご注意事項＞BEA Tuxedo V8.1J インストールの制限事項



Tuxedo8.1 を HP-UX プラットフォームにおいて、日本語 EUC 環境（ja_JP.eucJP）で インストールしようとすると「マルチバイト文字が正しくありません」というエラーメッセージが 出力され、インストールに失敗します。

日本語 SJIS 環境 LANG = ja_JP.SJIS でインストールして下さい。
SJIS および EUC の日本語メッセージカタログもインストールされます。

これは既知の問題（CR092679）として以下のページに書かれています。
http://otndnld.oracle.co.jp/document/products/tuxedo/tux81/relnotes/relnotea.htm#389165
関連項目 ＜ご注意事項＞BEA Tuxedo V8.1J インストールの制限事項



Tuxedo8.1で、サイレントインストール時に、USER_LOCALE に ja または ja_JP を指定しても日本語メッセージカタログがインストールされません

Tuxedo をサイレントモードでインストールすると日本語メッセージカタログがインストールされません。

以下のパッチを日本語環境でインストールすると日本語メッセージカタログも同時にインストールされます。
Solaris・Windows …… Rolling Patch 37以降
HP-UX …… Rolling Patch 51以降 ※

※ HP-UX でパッチを当てた際、TUXDIR/locale 配下の全ての日本語メッセージカタログについて ***．dummy というファイルや無効なシンボリック・リンクが作成されますが動作に支障はありません。

Rolling Patch の入手には保守契約が必要です。 入手の際はお問い合わせください。
関連項目 ＜ご注意事項＞BEA Tuxedo V8.1J インストールの制限事項



Windows において Tuxedo8.1 にパッチをインストールすることができません。

サイレントモードで Tuxedo8.1 をインストールする際、テンプレートファイルで BEAHOMES_NEW を指定しないと、パッチを当てる際に以下のエラーが出力されパッチのインストールに失敗します。 



これは、サイレントモードでのインストール時に使用したテンプレートファイルに BEAHOMES_NEW を追加し、再インストールすることで解決できます。
BEAHOMES_NEW については以下のページを参考にしてください。
http://otndnld.oracle.co.jp/document/products/tuxedo/tux81/install/inssil.htm#1039932

またレジストリを編集することで、上記の様な再インストール作業をする事なく問題を解決する事も出来ます。（レジストリの編集は各自の責任で行ってください。）
1.「スタートメニュー」から「ファイル名を指定」を選択します。
2.regedit を指定してレジストリエディタを起動します。
3.マイコンピュータ?HKEY_LOCAL_MACHINES?SOFTWARE?BEA Systems に文字列値を追加します。
4.値の名前に BEAHOMELIST、値のデータに Tuxedo V8.1J がインストールされているフォルダの絶対パス名を指定します。（例：C:?bea）
5.レジストリエディタを終了します。
6.レジストリ編集後、再びパッチのインストールを行ってください。

・関連項目 ＜ご注意事項＞BEA Tuxedo V8.1J インストールの制限事項



ラージファイルのファイルシステムを使用可能にしているのに、Tuxedo が出力を行うファイルが 2G バイトを超えるとファイルへの出力が行われません。

BEA Tuxedo は ラージファイルには対応しておりません。そのため、2GB を超えてファイルに書き込みを行おうとしても以降の書き込みが行われません。 Tuxedo では、 stdout、stderr というファイルを ${APPDIR} 配下(※デフォルト時)にオープンし、それぞれ標準出力、標準エラー出力がリダイレクトされます。そのため、特にこれら出力ファイルは定期的に初期化を行わないと、出力内容が書き込まれ続ける事になりますので、2G バイトを超えないようご注意下さい。



Windows のコントロールパネルから BEA Administration を起動させた際に見る事が出来る IPC Resources の各パラメータの意味を教えてください。

BEA Tuxedo はプロセス間通信(IPC) を使用しています。プロセス間通信は UNIX プラットフォームでサポートされている機能でプロセス同士の通信を可能にしています。Windows では BEA Proc MGR サービスによって、プロセス間通信をエミュレートしています。各パラメータの意味は下記ページを参照してください。
IPC Resources の各パラメータと UNIX のカーネルパラメータとの対応表
http://otndnld.oracle.co.jp/document/products/tuxedo/tux81/nt/ntadmin.htm#290843
UNIX の IPC 資源に関するカーネルパラメータ
http://otndnld.oracle.co.jp/document/products/tuxedo/tux81/install/insappd.htm#535994



「NLS:4: Cannot open message catalog ○○○_CAT」というメッセージが表示されますが、このメッセージはどういう意味ですか？

上記メッセージは Tuxedo がメッセージカタログをオープンできなかった事を示しています。

Tuxedo はメッセージを出力する際に ${TUXDIR}/locale ディレクトリの下で LANG 環境変数と同名のディレクトリからメッセージカタログを探します。メッセージカタログを見つける事が出来なかった場合、上記のメッセージが出力されます。

メッセージカタログを誤って削除してしまった場合はメッセージカタログを再インストールする必要があります。

また、Tuxedo7.1J、8.0J を日本語環境(EUC、SJIS)で運用するためには日本語メッセージカタログのインストールが別途必要となり、正しくインストールを行っていない場合も、Cannot open message catalog が出力されます。 Tuxedo7.1J、8.0J に日本語メッセージカタログをインストールするには以下を参照してください。
Tuxedo7.1J
 UNIX→http://otndnld.oracle.co.jp/document/products/tuxedo/docs71j/html/instunix.htm
 Windows→http://otndnld.oracle.co.jp/document/products/tuxedo/docs71j/html/instux_j.htm
Tuxedo8.0J
http://otndnld.oracle.co.jp/document/products/tuxedo/tux80j/ja/relnotes_j.htm

※Tuxedo8.1J を日本語環境で使用したい場合はインストール時に以下の点にご注意下さい。
BEA Tuxedo V8.1J インストールの制限事項


 
tmadmin コマンドを実行すると、「TMADMIN_CAT:199: WARN: 管理者になることができません。Limited set of commands available.」というメッセージが表示されます。

tmadmin コマンドは同時に１つしか実行できません。本メッセージは tmadmin コマンドの２重立ち上げにより発生しています。このメッセージが出力されると同時に、ULOG には以下のようなメッセージが出力されます。

LIBTUX_CAT:577: ERROR: Unable to register because the slot is already owned by another process

tmadminコマンドを複数起動する場合には、２つめ以降のコマンド実行では、起動／停止などの機能には制限がかかり、参照系のコマンドしか実行できません。

また 以下のように-r オプションを付けて実行すると明示的に参照モードでの実行となり、tmadmin コマンドを複数実行した場合でも、エラーメッセージは出力されません。


%% tmadmin -r

参照系のオペレーションのみを行う場合、-r オプションを付加することにより、ULOG 上のエラーメッセージ出力を抑制できる上に、オペミスによる誤ったコマンド投入を防止できます。



Tuxedo インストール時にライセンスファイルもインストールを行おうとした所、「ライセンス・コンフィギュレーション・エラー」が発生します。

Tuxedo のインストール時にライセンスファイルをインストールするかどうかを選択できます。ここで「すぐにライセンス・ファイルをコピーします」を選ぶと、ライセンスファイルを格納しているファイル・パスを聞かれますが、以下の事に注意しないと、ライセンスファイルを正常にインストールする事が出来ません。


===============================================================
ライセンスの選択オプション
-------------

1- すぐにライセンス・ファイルをコピーします
2- あとでライセンス・ファイルをコピーします

数字を入力してください: 1
ライセンス・ファイルへのパスを指定してください:

 ===============================================================
1.ファイル・パスにはディレクトリを指定する。
2.ファイル・パスを指定する際は絶対パスで指定する。
3.上記で設定したディレクトリにライセンスファイルを lic.txt の名前で保存する。

Tuxedo インストール時に失敗しても、後から ${TUXDIR}/udataobj ディレクトリにライセンスファイルを lic.txt という名前で格納する事でインストールできます。



Tuxedoが、32bit用か64bit用かは、どうやって確認できますか？

■Tuxedo V8.1の場合

以下のコマンドを実行することで、インストールされているTuxedoのbit数を確認する事が出来ます。


$ tmadmin -v

＜Tuxedoが64bitの場合＞

一行目に64bitであることが表示されます。


$ tmadmin -v

 INFO: BEA Tuxedo, Version 8.1,64-bit, Patch Level 172
 INFO: Serial #: XXXXXXXXX-XXXXXXXXXX, Maxusers 100
 INFO: Licensed to: BEA Japan
 INFO: 56-bit Encryption Package

＜Tuxedoが32bitの場合＞
 一行目に32bitであることが表示されます。


$ tmadmin -v

 INFO: BEA Tuxedo, Version 8.1,32-bit, Patch Level 164
 INFO: Serial #: XXXXXXXXX-XXXXXXXXXX, Maxusers 100
 INFO: Licensed to: BEA Japan
 INFO: 56-bit Encryption Package

■Tuxedo V6.5の場合

以下のコマンドを実行することで、インストールされているTuxedoのbit数を確認する事が出来ます。


$ tmadmin -v

＜Tuxedoが64bitの場合＞

一行目に64bitであることが表示されます。


$ tmadmin -v

 INFO: TUXEDO(r) System Release 6.5 -(64-bit)
 INFO: Serial #: XXXXXXXXX-XXXXXXXXXX, Maxusers 100
 INFO: Licensed to: BEA Japan

＜Tuxedoが32bitの場合＞

bitに関しては何も表示されません。


$ tmadmin -v

 INFO: TUXEDO(r) System Release 6.5
 INFO: Serial #: XXXXXXXXX-XXXXXXXXXX, Maxusers 100
 INFO: Licensed to: BEA Japan



●【MP 構成に関する質問】

マイグレーション機能を使用したいのですが、サーバの移行は自動的に行ってはくれないのですか？

残念ながら、自動的にサーバの移行を行うことはできません。

tmadminコマンドを用いて、管理者が手動で移行作業を行う必要があります。



スレーブノードにも WSL / WSH プロセスを起動することはできますか？

はい。もちろん可能です。
WSL を起動したいノード上のサーバグループを指定して WSL をコンフィギュレーションしてください。



最大何台のマシンを MP 構成で管理することができますか？

最大で 8191 台のマシンを構成できます。

UBBCONFIG ファイルの RESOURCES セクション中のパラメータである MAXMACHINES でノード数を設定しますが、デフォルトでは 256 となっています。



●【/WS に関する質問】

複数の WSL を起動している場合に、/WS クライアントがある WSL への接続を失敗したときに、自動的に他の WSL に接続させるようにするにはどうすればよいのでしょうか？

/WS クライアントを実行しているマシンの環境変数 WSNADDR に、複数のネットワークアドレスを指定することによって実現できます。

複数のアドレスは、カンマ区切りのリストを使用して指定します。次に例を示します。


WSNADDR = //machine1:3050, //machine2:3050, //mahcine3:3051

複数のアドレスを指定すると、接続が確立されるまで左から右の順序でアドレスが試されます。

また、ランダムなアドレスの選択もサポートされています。ランダムなアドレスの選択を使用する場合は、アドレス・リストの任意のメンバをかっこで囲まれたパイプ区切り ( | ) のネットワーク・アドレス・グループとして指定します。次に例を示します。


WSNADDR = (//machine1:3050 | //machine2:3050), //machine1:7000

この形式を使用すると、かっこで囲まれたアドレスのいずれか ( //machine1:3050 または //machine2:3050 ) がランダムに選択されます。かっこ内のいずれかのアドレスに対する接続が失敗した場合は、上記の例では次に//machine1:7000 のネットワークアドレスに対する接続が試みられることになります。



WSL のメッセージ圧縮機能を設定した場合、クライアントからのメッセージも圧縮されるのですか？

はい。サーバの起動時に -c オプションを指定すれば、サーバ側からのメッセージだけでなく、クライアント側からのメッセージも自動的に圧縮されます。



WSL の -T オプションと -N オプションとの違いは何ですか？

-T オプションは、/WS クライアントからの接続のアイドル時間のタイムアウトを設定するためのパラメータです。

/WS クライアントが Tuxedo アプリケーションに接続されている状態で、-T オプションで指定した時間の間に要求が一度も発生しなかった場合、サーバ側からソケットを開放します。
この機能は、おもに /WS 接続に WAN などを使用している場合の通信料金を節約するために使用します。
また、古い /WS 接続セッションが残り続けることによってセッションが増加し続け、MAXACCESORS パラメータの制限に引っかかってしまうような問題が発生した場合に、このオプションを指定することによって問題を回避できるようになります。

一方 -N オプションは、/WS クライアントが Tuxedo サービスに要求を送信してから、応答を受信するまでのタイムアウトを設定するためのパラメータです。

このタイムアウトが発生した場合、クライアント側からソケットを開放します。
ここで注意しなければならないのは、このタイムアウト時間を短くしてしまうと、サーバ側の処理に時間がかかっているだけの（ネットワーク障害ではない）場合でもソケットを開放してしまうということです。
 １回の呼び出しに対する処理時間が長いサービスが存在する場合、-N オプションで指定するタイムアウトの値を適切な値に設定しないと、/WS クライアントからの要求が頻繁に失敗してしまうことになりかねません。



WSH のプロセス数は MAXWSCLIENTS に計上されますか？

いいえ。MAXWSCLIENTS は WSL のプロセス数だけを計上します。
WSH のプロセス数は MAXACCESSORS に計上されます。



ファイアウォールを越えて /WS クライアントが接続しようとすると、tpinit が TPESYSTEM でエラーリターンし、接続ができません。

ファイアウォールを越えて /WS クライアントがサーバノードへと接続するには、いくつかの設定が必要になります。詳細は、役立つノウハウのファイアウォールを越えて /WS クライアントが接続するには？をご参照ください。



TCP の KEEPALIVE 機能は /WS構成時の WSクライアント-サーバ間にも適用されているのですか？

/WS 構成時に TCPレベル の KEEPALIVE 機能を設定するためには UBBCONFIG の *SERVERS セクションの WSL に -K オプションを指定する必要があります。
WSL の -K オプションの詳細については、/WS の KeepAlive 機能をご参照ください。



WSH のメモリサイズが大きく増加しています。メモリリークでしょうか？

WSH は、/WS クライアントからの電文を受信する際、メッセージの最大サイズの 8 倍から最大 13 倍のバッファを獲得し、リサイクルを行います。ですので正常な動作であり、メモリリークではありません。/WS クライアントで大きな電文をやりとりする場合には注意が必要です。

●【その他の機能に関する質問】

ドメイン間のネットワーク障害を検出する機能はありますか？

バージョン 8.1 から ドメイン間の KEEPALIVE 機能が追加されました。この機能を用いれば、ドメイン間のネットワーク障害を検出し、自動的にコネクションを切断することが可能になります。ドメイン間 KEEPALIVE にはTCPレベルのKEEPALIVEと、アプリケーションレベルのKEEPALIVEの２種類ございます。詳しくは下記 ホームページをご覧下さい。
/Domains の KeepAlive 機能
http://otndnld.oracle.co.jp/document/products/tuxedo/tux81/rf5/rf521.htm#3649

バージョン 8.1 以前（6.5、 7.1、 8.0）ではパッチの適用によりTCPレベルのKEEPALIVE機能を使用できます。 KEEPALIVE機能の設定方法は8.1とは異なり、環境変数「GW_KEEPALIVE=Y」を設定することにより実現致します。 


BEA TUXEDOのバージョン

必要なパッチレベル

BEA TUXEDO 6.5J 456 
BEA TUXEDO 7.1J 146 
BEA TUXEDO 8.0J 121 


パッチは、こちらをご覧いただき、ご請求ください。

ドメイン間の KEEPALIVE 機能を使用しない場合は、アプリケーションからの同期リクエストで発生する TPETIME でネットワーク異常を検出します。



トランザクションの伝播回数に制限はあるのでしょうか？

バージョン 6.5 以前の場合
1 トランザクション内で関わることが可能なグループ数は 1 ドメイン内につき 16 グループです。
 将来の拡張分を含めて考えて、1 ドメイン内につき 16 グループ内で収まるような設計を行う必要があります。
また、1 トランザクション内で関わることが可能なドメイン数は 16 ドメインまでとなっています。 すなわち、最大 256 グループがトランザクションに参加できることになります。

バージョン 7.1 以降の場合
1 トランザクション内でかかわることが可能な最大ドメイン数が 32767 まで拡張されています。デフォルトでは以前のバージョンと同じ 16 ドメインとなっています。
この値は、DMCONFIG ファイル内の DM_LOCAL_DOMAINS セクションの MAXRDTRAN パラメータによって調整することができます。



/Q の再試行機能はトランザクションモードでなくても使用可能でしょうか？

いいえ。/Q の再試行機能はトランザクションモードのときのみ有効です。



TRANTIME の値と、tpbegin() に指定するタイムアウト時間の値は何が違うのですか？

UBBCONFIG の SERVICES セクションのパラメータ AUTOTRAN を Y に設定し、自動的にトランザクションを開始した場合、TRANTIME で指定した時間がトランザクションタイムアウトに使用されます。

これに対して、tpbegin() を使用したトランザクションでは、TRANTIME の値は参照せず、引数のトランザクションタイムアウト値を使用します。



トランザクションを開始( tpbegin )したイニシエータが、会話型処理が完了する前に tpcommit() を行うとどうなるのでしょうか？

会話型処理が完了しないような状況で tpcommit() 処理を行うとエラーとなり、rollback 処理が自動的に動作します。



tpbegin() から tpcommit() 間で何らかの障害を検出した場合、tpabort() をコールする必要がありますか？

エラーを検出した時には tpabort() をコールするようにプログラミングすることをお薦めします。

Tuxedo ランタイムシステムがエラーを検出すると、トランザクションのフラグを「アボートのみ」に設定します。「アボートのみ」に設定された後の各ATMIコールの動作は、エラーの種類によって異なります。
たとえば、トランザクション中で呼び出されたあるサービスが TPESVCFAIL でエラーリターンした場合は、トランザクション境界内の以後のシーケンスのうち、TPNOREPLY 、TPNOTRAN および TPNOBLOCK が指定された tpacall() だけは正常に呼び出され、そのほかの呼び出しは TPETIME でエラーリターンします。
これらの呼び出しを行った後、トランザクションの終端ではじめてトランザクションがアボートされることになります。

すなわち、もし TPESVCFAIL などのエラーが検出された時点で、後の呼び出しは行わずにすぐさまアボートしたいのであれば、明示的に tpabort() を呼ぶようなロジックを組み込んでください。



TP-Tux 、TP-TUX 、PCTUX と組み合わせて使用できますか？

組み合わせての使用はサポート対象外ですのでご注意下さい。



異なるバージョンの BEA Tuxedo 間で接続することはできますか？

できます。
ただし、V7.1J 以降の BEA Tuxedo と、V6.5J 以前の BEA Tuxedo とを相互接続する場合、新しいバージョン側で下位互換性を保つための特別な設定が必要になります。詳しくは移行ガイドをご覧ください。



Tuxedo のアプリケーションでシグナルを使用できますか？

不可能ではありませんがお勧めできません。

シグナルは Tuxedo 内部でも使用されていますので、使用する場合には細心の注意が必要です。
 可能な限り使用しないことをお勧めします。



Tuxedo アプリケーションのシグナルハンドラ中で ATMI を使用できますか？

使用できません。

Tuxedo のライブラリは残念ながらリエントラント可能ではありません。



Tuxedo で送受信可能なメッセージのサイズは最大何バイトですか？

tpcall() などにおけるバッファの大きさ指定の型は long なので、Tuxedo としての最大サイズは long の最大値ということになります。
しかし、実際には実装メモリ、OS の設定、一時ファイルが作成されるディスクの空き容量などによって制限されます。



クライアントアプリケーションが出力する Tuxedo メッセージを日本語化するにはどうすればよいのでしょうか？

メッセージを日本語化するには、クライアントアプリケーションで setlocale() を実行する必要があります。

詳しくは Tuxedo オンライン・マニュアルの《リファレンス → セクション3C → setlocale(3c)》をご覧下さい。



Windows 版 BEA Tuxedo と Visual C++ バージョンの関係はどうなっていますか？

BEA Tuxedo で使用可能な Visual C++ のバージョンは、BEA Tuxedo「ユーザーズ・マニュアル」 ”プラットフォーム・データシート”に記載されています。
 記載のバージョン以降の Visual C++ については、Microsoft 社が互換性を保証しているバージョンについては動作可能です。



Tuxedo サーバまたはクライアントアプリケーション（Tuxedo コマンド含む）実行時に "/usr/lib/dld.sl: Can't open shared library" と表示され、実行できません。

Tuxedo ライブラリの動的リンクに失敗しています。

環境変数 SHLIB_PATH （HP-UX の場合） または LD_LIBRARY_PATH （Solaris及びUX/4800 の場合） が、${TUXDIR}/lib を指定しているか確認してください。

また、HP-UX のデフォルト設定では、環境変数 SHLIB_PATH 指定による、ライブラリの動的リンクは無効であり、アプリケーション実行時には作成時の静的リンク先のライブラリを使用します。

アプリケーションを作成する際に環境変数 CFLAGS に -Wl,+s を指定することにより、環境変数 SHLIB_PATH によるライブラリの動的リンクが有効となります。

ただし、BEA Tuxedo V6.5J 以前においては、環境変数 CFLAGS に -Wl,+s を指定する必要がありますが、BEA Tuxedo V7.1J 以降においては、アプリケーションのビルド時に自動的に -Wl,+s オプションが指定されるようになっており、明示的に CFLAGS を指定する必要はありません。

なお HP-UX 11.11 では、 su コマンドでユーザを変更した際に SHLIB_PATH 環境変数の値が引き継がれません。 従って su の延長で tmboot などの Tuxedo コマンドを実行した際にも、当エラーが発生し、正常に実行することができません。

この状況を回避する為には、PHCO_27781 パッチ （OSパッチ） を適用した上で、 /etc/default/security ファイルに "SU_KEEP_ENV_VARS=SHLIB_PATH" の行を追加する必要があります。



DOMAIN構成において、GWTDOMAINプロセスが「LIBGW_CAT:1029 ERROR:サービス要求がエラー "TPESVCERR - 要求を処理中にサーバでエラーがありました。"のためリモートサイトに転送されません。」 と表示され、電文の送信に失敗します

このメッセージは別マシンからDOMAIN経由で送信してきた電文を 自ノードのサービスに転送しようとしたが、メッセージキューにて ブロックが発生し、転送に失敗した場合に発生します。

GWTDOMAINが自ノードのサーバプロセスに対し電文を送信する場合は、必ずノンブロッキングモードで送信されます。メッセージキュー関連のカーネルパラメータ( msgmap,msgseg,msgssz,msgtql ) を拡大してメッセージキューがあふれないようにして下さい。



Q_CAT:1447 が頻繁に出力されます。

以下の原因が考えられます。
1.高負荷時におけるセマフォロックの多発
2.セマフォ関連のパラメータ不足

1.各プロセスが頻繁にセマフォロックをかけようとして競合が発生しやすくなります。 競合が発生すると、後から実行する I/O 要求はブロックされ ubbconfig の RESOURCES セクションで 指定された SPINCOUNT 回数だけリトライした後、一定時間ウェイトする動作を繰り返します。 本動作が50回行われると以降Q_CAT:1447 のエラーを出力します。 詳しくはメッセージキューアクセスの競合と SPINCOUNTをご覧ください。

2.tmboot -c を実行するとTuxedoで使用する必要最低限の ipc 資源が表示されます。 カーネル・パラメータの SEMUME・SEMMNU 等と比較して値が不足していないかを確認してください。



tmboot しようとしたところ、ULOG に「LIBTUX_CAT:296: ERROR: _tlog_open: _gp_tblopen: VTOC が初期化されていません。」が出力され立ち上げに失敗します。

TLOG を作成してください。

このエラーは UBBCONFIG に TLOG の記述があるにもかかわらず、TLOG を作成していない場合に出力されます。

TLOG の作成手順
1.tmadmin を実行して管理モードを起動
2.tmadmin の内部コマンド crdl を実行して汎用デバイス・リストにエントリを作成
3.tmadmin の内部コマンド crlog を実行してログファイルを作成
4.tmadmin の終了

詳しくは BEA Tuxedo のホームページ 「Tuxedo コマンドリファレンス」のtmadmin(1)をご覧ください。



サーバの多重度をあげているにも関わらず、性能が思う様に出ません。

SSSQ(Single Server Single Queue) では必須ではありませんが、LDBAL を有効にしておかないと、 同一サービスを提供する複数サーバ間でロードバランシングが十分に機能せず、一つのサーバに処理が 集まり、性能が思うように出ないことがあります。

###############################################################################

●Oracle　TUXEDO　問題解決資料収集手順
(HP-UX、Solaris、RHEL版)

●-- 目次 --
第１章　　障害対応・確認方法
 １－１　　障害対応フロー
 １－２　　システムメッセージの確認方法
 １－３　　トレース確認方法
第２章　情報収集
 ２－１　　構成記述ファイル
 ２－２　　tmunloadcf実行結果
 ２－３　　ドメイン構成記述ファイル
 ２－４　　dmunloadcf実行結果
 ２－５　　ULOG
 ２－６　　XAtrace(ORACLE用)
 ２－７　　stdout,stderr
 ２－８　　coreファイルの分析結果
 ２－９　　パッチレベル
 ２－１０　ライセンス
 ２－１１　IPC 資源ステータス
 ２－１２　プロセスステータス
 ２－１３　ネットワークステータス
 ２－１４　カーネルパラメータ 
 
●第１章　　障害対応・確認方法
●１－１　　障害対応フロー

障害対応フロー図




●１－２　　システムメッセージの確認方法

ULOG を開いて "CAT" という文字列をキーにして警告またはエラーのメッセージを検索して下さい。
ULOG の探し方は第２章の２－５を参照して下さい。

(サーバ側の表示例)

LIBTUX_CAT:1397: 警告: tpreturn トランザクション処理が異常終了しました。

上記のようなメッセージが出力されている場合、「システムメッセージマニュアル」でLIBTUX_CAT:1397を確認して下さい。

(システムメッセージマニュアルの記述例)


1397 WARN: tpreturn transaction processing failure

1397 警告: tpreturn トランザクション処理が異常終了しました。

説明

tpreturn() でトランザクション処理エラーが発生したので、トランザクションは中途終了します (まだ中途終了していない場合)。原因として、サービス・ルーチンの実行時間が非常に長かったため、tpreturn() の呼び出し前にトランザクションがタイムアウトしたと考えられます。このユーザ・ログが発行されるのは、サービス・ルーチンに制御が戻らないためです。サービス・ルーチンを呼び出したプロセスは、エラー・リターン・コードを受信します。

アクション

このトランザクションの完了の詳細については、ユーザ・ログを参照します。tmadmin の printtrans コマンドを使用しても、トランザクションの詳細がわかります。

関連項目

tmadmin(1)



目次へ

●１－３　トレース確認方法

環境設定： トレースを採取するには、クライアント側で環境変数TMTRACEを設定して下さい。

(実行例)

# setenv TMTRACE atmi+iatmi+xa:ulog: (csh の場合)

設定後、システム管理者に障害の再現を依頼して下さい。クライアント側とサーバ側の ULOG に TRACE 情報が出力されますので、ディスクフルとならないよう注意して下さい。

また、動的にトレースを採取したい場合は、以下のコマンドを実行してください。

# tmadmin
 > chtr atmi+iatmi+xa:ulog:
  

動的トレースの解除は以下のコマンドを実行します。

# tmadmin
 > chtr -m all off
  

トレースが採取できるように環境設定がされている場合は以下のような内容がULOGに出力されます。(トレースレベルが "atmi" の場合)

例１(クライアント側)

131439.rafale!?proc.8521.9662128.0: TRACE:at:{ tpinit(NULL)
 131439.rafale!?proc.8521.9662128.0: TRACE:at:} tpinit = 1
 131439.rafale!?proc.8521.9662128.0: TRACE:at:{ tpalloc("STRING", "", 7)
 131439.rafale!?proc.8521.9662128.0: TRACE:at:} tpalloc = 0x0xa287808
 131439.rafale!?proc.8521.9662128.0: TRACE:at:{ tpalloc("STRING", "", 7)
 131439.rafale!?proc.8521.9662128.0: TRACE:at:} tpalloc = 0x0xa287ce8
 131439.rafale!?proc.8521.9662128.0: TRACE:at:{ tpcall("TOUPPER", 0x0xa287808, 0, 0x0x7fffaacf1390, 0x0x7fffaacf1388, 0x0)
 131439.rafale!?proc.8521.9662128.0: TRACE:at:} tpcall = 0
 131439.rafale!?proc.8521.9662128.0: TRACE:at:{ tpfree(0x0xa287808)
 131439.rafale!?proc.8521.9662128.0: TRACE:at:} tpfree
 131439.rafale!?proc.8521.9662128.0: TRACE:at:{ tpfree(0x0xa278658)
 131439.rafale!?proc.8521.9662128.0: TRACE:at:} tpfree
 131439.rafale!?proc.8521.9662128.0: TRACE:at:{ tpterm()
 131439.rafale!?proc.8521.9662128.-2: TRACE:at:} tpterm = 1
 131439.rafale!?proc.8521.9662128.-2: TRACE:at:{ tpterm()
 131439.rafale!?proc.8521.9662128.-2: TRACE:at:} tpterm = 1
  

例２(サーバ側)

131724.310.cars!simpserv.15206.1.0: 02-09-2009: Tuxedo Version 9.1, 64-bit
 131724.310.cars!simpserv.15206.1.0: LIBTUX_CAT:262: INFO: Standard main starting
 131724.310.cars!simpserv.15206.1.0: TRACE:at:{ tpsvrinit(12, "simpserv -g 10 -i 100 -u cars -U /TUXEDO1/home/makita/tux_test/wsl/ULOG -m 0 -A")
 131724.310.cars!simpserv.15206.1.0: Welcome to the simple server
 131724.310.cars!simpserv.15206.1.0: TRACE:at:} tpsvrinit = 0
 131730.460.cars!simpserv.15206.1.0: TRACE:at:{ tpservice({"TOUPPER", 0x0, 0x6000000000053758, 7, 0, 4294967295, {1234153050, 0, 150}})
 131730.460.cars!simpserv.15206.1.0: massage size is 7
 131730.460.cars!simpserv.15206.1.0: TRACE:at:{ tpreturn(2, 0, 0x6000000000053758, 0, 0x0)
 131730.460.cars!simpserv.15206.1.0: TRACE:at:} tpreturn [long jump]
 131730.460.cars!simpserv.15206.1.0: TRACE:at:} tpservice
  

クライアント/サーバ側のアプリケーションが存在しているディレクトリから ULOG を開いて、tperrno を検索して下さい。

(クライアント側の表示例)

TRACE:at:} tpcall = -1[tperrno TPETIME]
  

上記のようなメッセージが出力されている場合、「リファンレンスマニュアル」のセクション(3c)で tpcall を探し、エラーコード TPETIME の記述を確認して下さい。

(リファンレンスマニュアルの記述例)


エラー

異常終了時には、tpcall() は tperrno を次のいずれかの値に設定します (特に記述した場合を除いては、エラーが呼び出し元のトランザクションに影響を及ぼすことはありません)。

………

[TPETIME]

このエラー・コードは、タイムアウトが発生したか、または現在のトランザクションがすでに「ロールバックのみ」とマークされているにもかかわらず tpcall() が試行されたことを示します。

………



目次へ

●第２章　情報収集

障害発生時にはシステム管理者の協力を得て以下の情報を収集して下さい。
構成記述ファイル
tmunloadcf 実行結果
ドメイン構成記述ファイル
dmunloadcf 実行結果
ULOG
XAtrace(ORACLE用)
stdout, stderr
core ファイルの分析結果
パッチレベル
ライセンス
IPC 資源ステータス
プロセスステータス
ネットワークステータス
カーネルパラメータ

～はじめに～

以下は障害情報を収集するにあたって必要となるディレクトリ情報です。
ディレクトリは設定により異なりますので、システム管理者に確認するか、構成記述ファイルで確認して下さい。

${TUXDIR}：TUXEDO のパッケージがインストールされているディレクトリ

${APPDIR}：アプリケーションが存在しているディレクトリ



目次へ

●２－１　構成記述ファイル

ファイル名：システム管理者に確認して下さい。

ディレクトリ：システム管理者に確認して下さい。

(構成記述ファイルの例)

*RESOURCES
 IPCKEY 60011
 DOMAINID simpapp
 MASTER simple
 MAXACCESSERS 200
 MAXSERVERS 100
 MAXSERVICES 100
 MODEL SHM
 LDBAL N
 *MACHINES
 DEFAULT:
 ikura
 LMID=simple
 APPDIR="/TUXEDO1/home/USER/simpapp"
 TUXCONFIG="/TUXEDO1/home/USER/simpapp/tuxconfig"
 TUXDIR="/TUXEDO1/hpux11iv2/tuxedo91/tuxedo9.1"
 TLOGDEVICE="/TUXEDO1/home/USER/simpapp/TLOG"TLOGSIZE=100
 MAXWSCLIENTS=50
  



目次へ

●２－２　tmunloadcf 実行結果

実行結果を適当なファイルに保存して下さい。

(実行例)

# tmunloadcf > tmunloadcf.out (リダイレクトで適当なファイルに保存)
 # ls -l tmunloadcf.out (正しく保存されているかを確認)
-rw-r--r-- 1 takada tuxedo 1303 3月 26日 13:29 tmunloadcf.out
  

上記の表示例のように、ファイルサイズが0になっていないことを確認して下さい。



目次へ

●２－３　ドメイン構成記述ファイル

※注意： /Domainの機能を使用しているかどうかをシステム管理者に確認し、使用している場合は採取をして下さい。

ファイル名：システム管理者に確認して下さい。

ディレクトリ：システム管理者に確認して下さい。

(ドメイン構成記述ファイルの例)

*DM_LOCAL
 TDOM1
 GWGRP="GWTGRP"
 TYPE=TDOMAIN
 ACCESSPOINTID="TDOM1"

*DM_REMOTE
 TDOM2
 TYPE=TDOMAIN
 DOMAINID="TDOM2"
 ACCESSPOINTID="TDOM2"

*DM_TDOMAIN
 TDOM1 NWADDR="//10.17.55.103:5001"
 TDOM2 NWADDR="//10.17.55.94:5002"

*DM_IMPORT
 TOUPPER RACCESSPOINT="TDOM2"
  



目次へ

●２－４　dmunloadcf 実行結果

※注意： /Domainの機能を使用しているかどうかをシステム管理者に確認し、使用している場合は採取をして下さい。

(実行例)

# dmunloadcf > dmunloadcf.out (リダイレクトで適当なファイルに保存)
 # ls -l dmunloadcf.out (正しく保存されているかを確認)
-rw-r--r-- 1 takada tuxedo 956 3月 26日 14:00 dmunloadcf.out

上記の表示例のように、ファイルサイズが0になっていないことを確認して下さい。



目次へ

●２－５　ULOG

※注意： ファイル名、ディレクトリの設定によって異なります。具体的には、構成記述ファイルの *MACHINES セクション内の ULOGPFX パラメータに指定されたパスおよびファイル名に日付が付加されたものが作成されます。デフォルトでは、${APPDIR} に ULOG.****** というファイルが作成されます。

ファイル名：ULOG.021609 など( 021609 (mmddyy形式) ⇒ 2009 年 2 月 16 日)

ディレクトリ：ULOGPFX に指定されたパス もしくは ${APPDIR}

(構成記述ファイルの例)

*MACHINES
 ikura
 LMID=simple
 APPDIR="/TUXEDO1/home/USER/simpapp"
 TUXCONFIG="/TUXEDO1/home/USER/simpapp/tuxconfig"
 TUXDIR="/TUXEDO1/hpux11iv2/tuxedo91/tuxedo9.1"
 TLOGDEVICE="/TUXEDO1/home/USER/simpapp/TLOG"
 TLOGSIZE=100 MAXWSCLIENTS=50
 LOGPFX="/TUXEDO1/home/USER/simpapp/log/ULOG"
  



目次へ

●２－６　XAtrace(ＯＲＡＣＬＥ用)

※注意：ORACLE の XA インターフェースを使用しているかどうかをシステム管理者に確認し、使用している場合は採取をして下さい。また、OPENINFOの値でDbgFlに0xFが指定されていることを確認してください。

ファイル名 ：xa_NULL021609.trc など (021609 ⇒ 2009 年 2 月 16 日)

ディレクトリ：構成記述ファイルの OPENINFO パラメータの LogDir 、${APPDIR} のいずれか、もしくは両方に出力される可能性があります。両方に出力されている場合は両方とも採取して下さい。

(構成記述ファイルの例)

..................................

*MACHINES
 ikura
 LMID=simple
 APPDIR="/TUXEDO1/home/USER/app"

..................................

*GROUPS
 GROUP
 LMID=simple GRPNO=2 OPENINFO=NONE
 TMSNAME=TMS_Oracle_XA
 TMSCOUNT=2
 OPENINFO="Oracle_XA:Oracle_XA+Acc=P/tux/tux+SesTm=30+
 LogDir=/TUXEDO1/home/USER/app/TRACE/mstr+MaxCur=5+DbgFl=0XF"

.........................




目次へ

●２－７　stdout、stderr

ファイル名、ディレクトリの設定によって異なります。具体的には、構成記述ファイルの *SERVERS セクション内の CLOPT パラメータに指定されたファイル名で作成されます。

以下は標準出力ファイル名に stdout 、標準エラー出力ファイル名に stderr を指定した場合の例です。simpserv プロセスの標準出力、標準エラー出力が各ファイルに出力されます。

(構成記述ファイルの例)

..................................

simpserv SRVGRP=APPGRP SRVID=100
 CLOPT="-A-o stdout -e stderr"

..................................


※注意：中身は何も出力されていない場合があります。

ファイル名：stdout, stderr (ubbconfigで指定)

ディレクトリ：カレントディレクトリ



目次へ

●２－８　core ファイルの分析結果

core ファイルが存在している場合、この core ファイルを用いて、障害箇所をある程度特定することが出来ます。

ファイル名：core (デフォルトの設定)

ディレクトリ：カレントディレクトリ

※注意：ulimitの設定値によっては、異常終了時に core ファイルが出力されない場合があります。 core ファイルを出力させるためには異常終了の前に以下のコマンドを実行してください。

(実行例)

# ulimit -c unlimited (coreダンプのサイズを無制限にする)
 # ulimit -c (変更したサイズの確認)
unlimited
  

２－８－１　ロードモジュールの特定

core ファイルがどのロードモジュールから出力されたかを調べるのに以下のコマンドを実行して下さい。

(実行例)

# file core
 core:core file from 'simpserv' - received SIGBUS
  

上記の表示例では、ロードモジュール名は simpserv になります。

２－８－２　ロードモジュールが使用するライブラリの調査

ロードモジュールがどのライブラリに依存しているかを調べるには、以下のコマンドを実行して下さい。

(実行例)

# chatr simpserv (OS が HP-UX の場合)
 # ldd simpserv (OS が RHEL もしくは Solaris の場合)
  

HP-UX の表示例

simpserv:
 64-bit ELF executable
 shared library dynamic path search:
 LD_LIBRARY_PATHenabledfirst
 SHLIB_PATH enabledsecond
 embedded pathenabledthird/TUXEDO1/hpux11iv2/tuxedo91/tuxedo9.1/lib:/usr/lib/hpux64:/opt/langtools/lib/hpux64
 shared library list:
 libtux.sl
 libbuft.sl
 libfml.sl
 libfml32.sl
 libengine.sl
 libnsl.so.1
 libpthread.so.1
 libc.so.1
 shared library binding:

.............................
  

RHEL の表示例

libtux.so => /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/libtux.so (0x00334000)
 libbuft.so => /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/libbuft.so (0x00a8d000)
 libfml.so => /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/libfml.so (0x007f0000)
 libfml32.so => /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/libfml32.so (0x009e7000)
 libengine.so => /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/libengine.so (0x00458000)
 libdl.so.2 => /lib/libdl.so.2 (0x00111000)
 libpthread.so.0 => /lib/tls/libpthread.so.0 (0x00b15000)
 libc.so.6 => /lib/tls/libc.so.6 (0x00cf8000)
 libutrace.so => /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/libutrace.so (0x00114000)
 libgiconv.so => /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/libgiconv.so (0x0078c000)
 libusort.so => /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/libusort.so (0x00116000)
 /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x0025b000)
  

Solaris の表示例

libtux.so.71 => /TUXEDO1/solaris10/tuxedo91_64/tuxedo9.1/lib/libtux.so.71
 libbuft.so.71 => TUXEDO1/solaris10/tuxedo91_64/tuxedo9.1/lib/libbuft.so.71
 libfml.so.71 => /TUXEDO1/solaris10/tuxedo91_64/tuxedo9.1/lib/libfml.so.71
 libfml32.so.71 => /TUXEDO1/solaris10/tuxedo91_64/tuxedo9.1/lib/libfml32.so.71
 libengine.so.71 => /TUXEDO1/solaris10/tuxedo91_64/tuxedo9.1/lib/libengine.so.71
 libpthread.so.1 => /lib/64/libpthread.so.1
 librt.so.1 => /lib/64/librt.so.1
 libsocket.so.1 => /lib/64/libsocket.so.1
 libnsl.so.1 => /lib/64/libnsl.so.1
 libm.so.2 => /lib/64/libm.so.2
 libthread.so.1 => /lib/64/libthread.so.1
 libc.so.1 => /lib/64/libc.so.1
 libutrace.so.71 => /TUXEDO1/solaris10/tuxedo91_64/tuxedo9.1/lib/libutrace.so.71
 libgiconv.so.71 => /TUXEDO1/solaris10/tuxedo91_64/tuxedo9.1/lib/libgiconv.so.71
 libaio.so.1 => /lib/64/libaio.so.1
 libmd5.so.1 => /lib/64/libmd5.so.1
 libmp.so.2 => /lib/64/libmp.so.2
 libscf.so.1 => /lib/64/libscf.so.1
 libdoor.so.1 => /lib/64/libdoor.so.1
 libuutil.so.1 => /lib/64/libuutil.so.1
 /platform/SUNW,Sun-Fire-T200/lib/sparcv9/libc_psr.so.1
  

２－８－３　障害箇所の調査

障害の発生したプロセスが、実行していたロードモジュール内のどの部分でシグナルを受け取ったか調査するためには、 core ファイルとロードモジュールが存在するディレクトリで gdb コマンドを使用します。プロンプトが (gdb) と表示され、入力待ちとなります。

# gdb ＜ロードモジュール名＞ ＜core ファイル名＞
 

(実行例)

# gdb simpserv core
 GNU gdb Red Hat Linux (6.3.0.0-1.62rh)
 Copyright 2004 Free Software Foundation, Inc.

.............................

Core was generated by `./simpcl foobar'.
 Program terminated with signal 8, Arithmetic exception.
 Reading symbols from /TUXEDO2/linux/tuxedo91_for4/tuxedo9.1/lib/libtux.so...done.
'
.............................

Loaded symbols for /TUXEDO1/linux/tuxedo91_for4/tuxedo9.1/lib/registry.so
 #00x08048919 in function ()
 (gdb)
  

※注意：gdb コマンドを用いて core ファイルを解析する際には、当該のロードモジュールが実行されていたときに使用されていたダイナミックライブラリ(手順２－８－２で調査したライブラリ群)が、実行時と同一のパスに存在する必要があります。

gdb コマンドの内部コマンド where を用いて、関数のスタックを表示します。関数スタックの一番上に表示されている関数名が、シグナルを受信した時点で実行中だった関数名になります。

(実行例)

(gdb) where
 #00x08048919 infunction ()
 #10x080488c5 in main ()


※注意：関数スタックの一番上に表示されている関数名が、ユーザが開発したアプリケーションの関数名である場合、アプリケーションに問題がある可能性が高くなります。お問い合わせの前に、該当する関数内の処理に問題がないかどうか確認してください。



目次へ

●２－９　パッチレベル

※注意：patchがあたっていない場合にはpatchlevファイルは存在しません。

ファイル名 ：patchlev

ディレクトリ：${TUXDIR}/udataobj

v8.0以降のバージョンでは、以下のコマンドでもパッチレベルを確認することができます。

# tmadmin -v
  

(実行例)

INFO: BEA Tuxedo, Version 9.1, 64-bit,Patch Level 105
 INFO: Serial #: 454493271161-2664953907511, Expiration NONE, Maxusers 1000000
 INFO: Licensed to: Customer
 INFO: 56-bit Encryption Package




目次へ

●２－１０　ライセンス

※注意：lic.txtは絶対にコピーして使わないで下さい。

ファイル名：lic.txt

ディレクトリ：${TUXDIR}/udataobj

lic.txt ファイルをそのままメールに添付してください。lic.txt の例を以下に示します。

.............................

[BEA TUXEDO]
 DEVELOPERS=******
 LICENSEE=******
 SERIAL=******
 TYPE=******
 USERS=******
 VERSION=******
 SIGNATURE=******

.............................
  



目次へ

●２－１１　ＩＰＣ資源ステータス

以下のような手順で、ipcs コマンドの結果を適当なファイルに保存して下さい。

※注意：スーパーユーザで実行して下さい。

(実行例)

# ipcs -a > ipcs.out (リダイレクトで適当なファイルに保存)
 # ls -l ipcs.out (正しく保存できているかを確認)
-rw-r--r-- 1 takada tuxedo 2447 3月 26日 15:32 ipcs.out
  

上記の表示例のように、ファイルサイズが0ではないことを確認して下さい。



目次へ

●２－１２　プロセスステータス

以下のような手順で、ps コマンドの結果を適当なファイルに保存して下さい。

(HP-UX の場合)

# ps -eflx > ps.out (リダイレクトで適当なファイルに保存)
 # ls -l ps.out (正しく保存できているかを確認)
-rw-r--r-- 1 takada tuxedo 3031 3月 26日 15:40 ps.out
  

(RHEL の場合)

# ps -eflww > ps.out (リダイレクトで適当なファイルに保存)
 # ls -l ps.out (正しく保存できているかを確認)
-rw-r--r-- 1 takada tuxedo 3031 3月 26日 15:40 ps.out
  

(Solaris の場合)

# ps -efl > ps.out (リダイレクトで適当なファイルに保存)
 # ls -l ps.out (正しく保存できているかを確認)
-rw-r--r-- 1 takada tuxedo 3031 3月 26日 15:40 ps.out
  

上記の表示例のように、ファイルサイズが0になっていないことを確認して下さい。



目次へ

●２－１３　ネットワークステータス

下記のような手順で、netstat コマンドの結果を適当なファイルに保存して下さい。

(実行例)

# netstat -an > netstat.out (リダイレクトで適当なファイルに保存)
 # ls -l netstat.out (正しく保存できているかを確認)
-rw-r--r-- 1 takada tuxedo 12837 3月 26日 15:44 netstat.out
  

上記の表示例のように、ファイルサイズが0になっていないことを確認して下さい。



目次へ

●２－１４　カーネルパラメータ

HP-UX の場合

※注意： Unix の場合、スーパーユーザで実行して下さい。

(実行例)

# kctune > kctune.out (リダイレクトで適当なファイルに保存)
 # ls -l kctune.out (正しく保存できているかを確認)
-rw-r--r-- 1 root tuxedo 3001 3月 30日 17:10 kctune.out
  

上記の表示例のように、ファイルサイズが0になっていないことを確認して下さい。

RHELの場合

sysctl -a の結果を適当なファイルに保存して下さい。

※注意： RHEL の場合、スーパーユーザで実行して下さい。

(実行例)

# sysctl -a > sysctl.out (リダイレクトで適当なファイルに保存)
 # ls -l sysctl.out (正しく保存できているかを確認)
-rw-r--r-- 1 root tuxedo 3829 3月 26日 15:48 sysctl.out
  

上記の表示例のように、ファイルサイズが 0 になっていないことを確認して下さい。

Solaris の場合

ファイル名：system

ディレクトリ：/etc

(実行例)

# cp /etc/system system.out (適当なファイルにコピー)
 # ls -l system.out (正しく保存できているかを確認)
-rw-r--r-- 1 takada tuxedo 3001 3月 30日 17:10 system.out
  

上記の表示例のように、ファイルサイズが0になっていないことを確認して下さい。

###############################################################################
●Tuxedo問い合せ時に必要となる情報
（Windows編）

→ Unix/Linux版はこちら

目次
第１章　はじめに__ 3
第２章　問い合せについて__ 4
第３章　基本情報__ 5
３－１　基本情報(1)－環境.. 5
３－２　基本情報(2)－状況.. 6
第４章　追加情報__ 7
４－１　追加情報(A) － 必須情報.. 7
４－２　追加情報(B) － 設定情報(設定ファイルなど) 8
４－３　追加情報(C) － トレース情報(ログファイルなど) 9
第５章情報採取手段__ 10
５－１　ライセンス.. 10
５－２　パッチレベル.. 11
５－３　IPC Resources. 12
５－４　イベントログ.. 14
５－５　Tuxedo詳細トレース.. 15
５－６　Tuxedo統計情報.. 16
５－７　ワトソンログ.. 18
５－８　XAトレース.. 20

●第1章　はじめに

●　　目的

本資料は、Tuxedoに対する問い合せを早期解決することを目的としています。
従来から、お客様に情報の提供を依頼している内容と、その情報を採取して頂き易くするために採取方法を紹介します。

●　　構成

「基本情報」、「追加情報」では、問い合せの際に提供して頂く情報を示します。
「情報採取方法」では、情報を採取するための方法を示します。

●第２章　問い合せについて

Tuxedoに関する技術的なお問い合せは、E-Mailにて受け付けています。所定のフォーマットに必要事項を記入の上、tuxedo@bea.jp.nec.comまでお送りください。

フォーマットは下記URLから入手することが可能です。


http://www.ubsw.nec.co.jp/products/BEA/files/tux_requestformat.txt

なお、フォーマットは変更する可能性があります。

●第３章　基本情報

問題が発生している環境および状況を把握するために以下の情報が必要となります。

これらはお問い合せフォーマットに含まれています。

●３－１　基本情報(1)－環境

下記は環境を確認するために必要となります。


No

大項目

小項目

フォーム

1 Tuxedoサーバ情報
(サーバ側環境) ＊Tuxedoサーバ製品名（バージョン、パッチレベル） 7 
＊サーバ側OS（バージョン、パッチ） 6 
・サーバ側コンパイラ 8 
2 Tuxedoクライアント情報
(クライアント側環境) ＊Tuxedoクライアント製品名(バージョン、パッチレベル) 10 
＊クライアント側OS（バージョン、パッチ） 9 
・クライアント側コンパイラ 11 
3 データベース情報 ・データベース製品（ベンダ、バージョン） 12 
・XA使用の有無 12 
・データベースとの接続形態 12 
4 その他 ・データベース以外でTuxedoと連携した製品 13 

・小項目：先頭に”＊”が付いているものは必須項目になります。
・フォーム：お問い合せフォーマットで対応する番号になります。

●３－２　基本情報(2)－状況

下記は状況を確認するために必要となります。


No

項目

説明

フォーム

1 ＊概要 問い合せの概要を簡潔に記入してください。 2 
2 ＊内容 問い合せの内容を詳細に記入してください。
(事象が発生した契機についても記入してください。) 17 
3 ＊再現性 再現頻度を以下から選択してください。
（常に、時々、まれに、なし、その他）
※その他の場合は説明を付けてください。 14 
4 ＊利用状況 利用状況を以下から選択してください。
（設計、開発、テスト、運用中、その他）
※その他の場合は説明を付けてください。 15 
5 ＊システム構成 サーバ、クライアントの台数などを記入してください。 4 

・項目：先頭に”＊”が付いているものは必須項目になります。
・フォーム：お問い合せフォーマットで対応する番号になります。

●第４章　追加情報

前記の基本情報のほかに、以下の情報を採取し提供して頂くこともあります。
なお、構成ファイルおよびログファイルについては必須になります。

●４－１　追加情報(A) － 必須情報

下記の情報は必須になります。最初のお問い合せ時に送付してください。


No

リスト

説明
1)必要となるケース
2)存在場所

A1 Tuxedo構成ファイル（ubbconfig） 1)　　　Tuxedoの構成定義を確認
2)　　　環境変数TUXCONFIGで指定した場所 
A2 Tuxedoログファイル（ULOG）
－サーバ側 1)　　　Tuxedoシステムが出力しているメッセージを確認
2)　　　ULOGPFXパラメータで指定した場所
　　※指定がない場合はAPPDIR配下 
A3 Tuxedoログファイル（ULOG）
－クライアント側 1)　　　Tuxedoシステムが出力しているメッセージを確認
2)　　　ULOGPFXパラメータで指定した場所
　　※指定がない場合はTUXDIR配下 

●４－２　追加情報(B) － 設定情報(設定ファイルなど)

下記の情報は、定義/設定を確認する際に必要となります。


No

リスト

説明
1)必要となるケース
2)存在場所

B1 Tuxedoドメイン構成ファイル
（dmconfig） 1)　　　Tuxedoドメイン構成定義を確認
2)　　　環境変数BDMCONFIGで指定した場所 
B2 RMファイル 1)　　　リソースマネージャの定義を確認（XA使用時）
2)　　　%TUXDIR%?udataobj配下 
B3 環境設定－サーバ側 1)　　　Tuxedoサーバ実行環境の設定を確認 
B4 環境設定－クライアント側 1)　　　Tuxedoクライアント実行環境の設定を確認 
B5 Tuxedoライセンス情報 1)　　　使用しているライセンスを確認
2)　　　%TUXDIR%udataobj配下の lic.txt ファイル
情報採取方法「①ライセンス」を参照 
B6 Tuxedoパッチ情報 1)　　　適用しているパッチレベルを確認
2)　　　%TUXDIR%?udataobj配下の patchlev ファイル
情報採取方法「②パッチレベル」を参照 
B7 IPC Resources設定情報 1)　　　IPC資源の設定を確認
2)　　　情報採取方法「③IPC Resources」を参照 

●４－３　追加情報(C) － トレース情報(ログファイルなど)

下記の情報は、トレースを確認する際に必要となります。



No

リスト

説明
1)説明必要となるケース
2)存在場所

C1 stderr、stdoutファイル 1)　　　アプリケーションによって出力されたメッセージを確認
2)　　　%APPDIR%配下
※何も出力されていない場合もあります。 
C2 トランザクションログファイル
（TLOG） 1)　　　グローバルトランザクションの状況を確認(グローバルトランザクション使用時)
2)　　　%TLOGDEVICE%で指定した場所 
C3 ドメイン･トランザクションログファイル（DMTLOG） 1)　　　グローバルトランザクションの状況を確認(ドメイン構成でグローバルトランザクション使用時)
2)　　　%DMTLOGDEV%で指定した場所 
C4 イベントログ 1)　　　イベントログに出力されているTuxedoに関するメッセージを確認
2)　　　情報採取方法「④イベントログ」を参照 
C5 Tuxedo詳細トレース 1)　　　通常のログファイル(ULOG)からでは有益な情報が得られず、より詳細な情報が必要な場合
2)　　　情報採取方法「⑤Tuxedo詳細トレース」を参照 
C6 Tuxedo統計情報 1)　　　Tuxedoシステムで現在の実行状態を確認
2)　　　情報採取方法「⑥Tuxedo統計情報」を参照 
C7 ワトソンログ 1)　　　Tuxedoまたはアプリケーションで発生したアプリケーション障害(アプリケーションエラーの発生など)を確認
2)　　　情報採取方法「⑦ワトソンログ」を参照 
C8 XAトレース 1)　　　XAインタフェースでの状況を確認
2)　　　情報採取方法「⑧XAトレース」を参照 

●第５章情報採取手段

ここでは、情報を確認および採取するための手段を示します。

●５－１　ライセンス

ライセンスファイルは、%TUXDIR%?udataobj配下の lic.txt ファイルになります。
(%TUXDIR%はTuxedoをインストールしたディレクトリです。)

●５－２　パッチレベル

%TUXDIR%?udataobj配下のpatchlevファイルに適用したパッチ一覧が表示されます。

patchlevファイルの最終行の左に表示されている番号が、適用されている現在のパッチレベルになります。(%TUXDIR%はTuxedoをインストールしたディレクトリです。)

下記のようなファイルが存在する場合、パッチレベルは89になります。


----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- -----

``#ident "@(#) udataobj/patchlev 　　　$Revision: 1.14.2.324 $"

9.1 Rolling Patch:

-----------------

001. CR271848 TUX8.1: domain security issue when connecting to remote domain

～～ (省略) ～～

088. CR354646 TUX 9.1 - tpdequeue() returns by TPENOENT when transaction timeout

089. CR355736 TUX9.1 : LIBWSC_CAT:1512 occurs when calling tpinit()/tpterm() in multiple thread

----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- -----

なお、pathlevファイルが存在しない場合、パッチは適用されていないことになります。

また、以下のコマンドを実行することでバージョン（パッチレベル）およびライセンスを確認することができます。（※なお、パッチレベルは8.1以降でのみ表示されます。）


> tmadmin -v

【実行例】


----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- -----

C:?bea?tux91?tuxap>tmadmin -v

INFO: BEA Tuxedo, Version 9.1, 32-bit, Patch Level 005

INFO: シリアルナンバー: xxxxx-xxxxx, 有効期限 NONE, 最大ユーザ数1000000

INFO: ライセンス先: XXXXX

INFO: 56 ビットの暗号化パッケージ

----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- ----- -----

※ここで確認した情報は、問い合せフォームの該当箇所へ記入するようにしてください。　　

●５－３　IPC Resources

IPC Resourcesの設定を確認するためには下記の手順で行います。

1) BEA Administrationへのアクセス
[スタート]→[設定]→[コントロールパネル]において[BEA Tuxedo9.1 Administration]を選択します。

2) [IPC Resources]の保存
[IPC Resources]ページを開き、その画面イメージをペイントなどのツールで保存してください。

3)ファイルの送付

　・2)で保存したファイルを送付してください。

図：[IPC Resources]ページ
－ 図：[IPC Resources]ページ －

●５－４　イベントログ


イベントログの情報を保存するためには下記の手順で行います。

1)イベントログの起動

　・[スタート]→[設定]→[コントロールパネル]において[管理ツール]を選択。

　・管理ツールにおいて[イベントビューア]を選択。
2)アプリケーションログの保存

　・イベントビューアにおいてアプリケーションを選択し、ツールバーの[操作]→

[ログファイルの名前を付けて保存]において、保存するファイル名を入力します。

3)ファイルの送付

・2)で保存したファイルを送付してください。

図：イベントビューア
－ 図：イベントビューア －

●５－５　Tuxedo詳細トレース

Tuxedo詳細トレースを採取するためには、トレース用パラメータを設定する必要があります。

A)環境変数として設定する場合

アプリケーションを実行する環境において以下の環境変数を設定します。


set TMTRACE=atmi+iatmi+xa:ulog

環境変数はアプリケーションを実行する前に設定する必要があります。
また、設定を解除するためには以下を設定します。


set TMTRACE=

B)tmadminのchangetrace(chtr)コマンドで設定する場合

tmadminコマンドの内部コマンドであるchangetrace(chtr)を実行します。


tmadmin

> chtr atmi+iatmi+xa:ulog

> q

設定された時点から、現在実行しているプロセスのみに対して採取します。
また、設定を解除するためには以下を実行します。


tmadmin

> chtr off

> q

《補足》

問題となっているプロセスが特定できる場合のみB)の方法で、通常はA)の方法を使用してください。

《注意事項》

詳細トレースはULOGファイルに出力されます。そのため通常よりULOGファイルのサイズが大きくなり、また、ファイルI/O(への書き込み)が頻繁になるため性能が低下します。したがって、運用環境で採取する際には十分に注意してください。

●５－６　Tuxedo統計情報

Tuxedoの統計情報を採取するためにはtmadminコマンドの内部コマンドを実行します。
アプリケーションおよび管理サービスに関する情報を採取する場合は、
printservice(psc) を実行します。
サービスの起動状態、利用状況などを確認することができます。

[実行例]

アプリケーションおよび管理サーバに関する情報を採取する場合は、
printserver(psr) を実行します。
サーバの起動状態、負荷状況などを確認することができます。

[実行例]

クライアントに関する情報を採取する場合は、
printclient(pclt) を実行します。
クライアントの接続状態などを確認することができます。

[実行例]

アプリケーションおよび管理サーバのキュー(待ち行列)関する情報を採取する場合は、
printqueue(pq) を実行します。
各サーバのキューの状態(メッセージの滞留状態)などを確認することができます。

[実行例]


●５－７　ワトソンログ

ワトソン博士(Dr.Watson)はアプリケーションの障害を検出するためのデバック用ツールです。

【デバッカとしてのワトソン博士の設定】

通常、Windowsではデフォルトとして設定されていますが、”Microsoft Visual Studio”(VC)などの開発環境がインストールされている場合には、ワトソン博士がデフォルトのデバッカとして設定されていない可能性があります。
このような場合には、以下のコマンドを実行しワトソン博士が設定されるようにします。


[スタート]→[ファイル名を指定して実行]で drwtsn32 -i と入力し[OK]をクリック

《補足》

「drwtsn32 -i」を実行すると、以下のレジストリ配下の内容を変更し、ワトソン博士をデフォルトのデバックツールとして設定します。


HKEY_LOCAL_MACHINE?SOFTWARE?Microsoft?Windows NT?CurrentVersion?AeDebug

[Debugger]の値には、自動起動するプログラムが指定されます。
ワトソン博士の場合は、drwtsn32 -p %ld -e %ld -g
VCの場合は、"%VC_DIR%?Common?MSDev98?Bin?msdev.exe" -p %ld -e %ld
（%VC_DIR%とはVCをインストールしたディレクトリ）

コマンドを実行する前に、念のため現在の設定を確認しておいてください。

【デバッグ情報】

●ログファイル

デバックの結果は drwtsn32.log という名前のファイルに保存され、デフォルトでは以下のディレクトリ配下に出力されます。


Documents and Settings?All Users?Application Data?Microsoft?Dr Watson

出力先はワトソン博士の設定画面で変更できます。
なお、デバッグの結果は同じログファイルに追加されていくため、障害発生時の箇所を送付ください。

●クラッシュダンプファイル

クラッシュダンプファイルを出力するためには、ワトソン博士の設定画面で以下を設定します。
[クラッシュダンプの種類]で「完全」を選択
オプション[ダンプシンボルテーブル]をチェック
オプション[クラッシュダンプファイルの作成]をチェック

user.dmp という名前で以下のディレクトリ配下に出力されますが、ファイル名および出力先はワトソン博士の設定画面で変更できます。


Documents and Settings?All Users?Application Data?Microsoft?Dr Watson?user.dmp



●５－８　XAトレース

XAトレース（Oracleトレース）を採取するためには、Tuxedoで下記の設定が必要になります。

【設定方法】

Tuxedo構成ファイル(ubbconfig)のGROUPSセクションにあるOPENINFOパラメータに以下のオプションフィールドを指定します。
LogDir (トレースファイル格納場所)
DbgFl (デバックフラグ)

【設定例】


OPENINFO="Oracle_XA:Oracle_XA+Acc=P/user/passward+SesTm=3600
+SqlNet=SCF1+LogDir=c:?tuxedo?ap+DbgFl=0xf"

XAインタフェースでエラーが発生した場合には、LogDirで指定したディレクトリに
###############################################################################
●Oracle Tuxedo　機能概要

●高度な分散トランザクション処理

■ 分散トランザクション処理

複数のネットワーク上に存在するアプリケーション・サーバ間、または異なる リソース・マネージャを使用しているアプリケーション・サーバ間のトランザ クションの整合性を保証します。

Tuxedo では、多種のリソース・マネージャと通信するために X/Open の XA イン タフェース標準を採用しています。XA 標準に準拠していれば任意のデータベ ース製品を使用する事ができ、同じトランザクション(基本単位)内で複数のサ イトにまたがるデータをアクセスできます。各サイトのサーバは、それぞれ異 なるデータベース製品を利用する事も出来ます。

BEA Tuxedo トランザクション管理サーバ（Oracle OTN）

トランザクション管理

■ イベント・ブローカ

イベントは、実行中のアプリケーション内で発生したある状態を、管理者又 はアプリケーションへ通知します。また、独自のイベントを定義することもできます。

イベント発生の通知元は、仲介者（イベント・ブローカ）にポストするだけで、通知先の状態や数を意識 する必要はありません。イベント・ブローカ　システムにより、運用の変化に引きずられない独立性の高いアプリケーションを組むことができます。

BEA Tuxedo イベント・ブローカ（Oracle OTN）

Tuxedo イベント・ブローカ

ページの先頭へ戻る

●リソース管理

■ セキュリティ

BEA Tuxedo は、認証、認可、データ暗号化によってアプリケーションのセキュリテ ィを確保しています。認証サーバによるサーバ毎のアクセス制御に加え、サービスレベルのアクセス制御リスト（ACL）により、サービ ス毎のアクセスコントロールも可能です。

また、BEA Tuxedo V7.1J 以降では、以下のようにセキュリティ機能が強化されています。
サードパーティ製のセキュリティ・システムのサポート
Tuxedo のプラグイン・アーキテクチャを利用すると、サードパーティ製の適切なプラグインを使用して、認証、認可、監査、または公開鍵によるセキュリティ機能（SSL 通信）を使用することができます。
メッセージ・ベースのデジタル署名
メッセージ・ベースのデジタル署名は、メッセージの送信者の ID を証明し、その内容を特定のメッセージ・バッファと結び付けることにより、Tuxedo のセキュリティ機能を強化します。メッセージ・ベースのデジタル署名では、エンド・ツー・エンドで内容がセキュリティ保護されます。つまり、メッセージ・バッファは、送信プロセスで発信され、受信プロセスで受け取られるまで保護されます。
56 ビットの暗号化
Tuxedo セキュリティ・パッケージの国際版 (リンク・レベルの暗号化付き) で 56 ビットの暗号化が完全に実現されています。

BEA Tuxedo セキュリティの管理（Oracle OTN）

Tuxedo セキュリティ管理

■ CORBA対応　※バージョン8.0J以降

Tuxedo 開発環境下では、CORBA Java 、C++ 、ActiveX クライアントが利用可能です。また、IIOP を介してサード・パーティの ORB と相互に通信したり、RMI/IIOP を介して WebLogic Server などのサーバ・サイド Java アプリケーションと相互に通信することも実現できます。

pdfTuxedo CORBA説明資料

※ただし、BEA WebLogic Serverとのコネクティビティについては、WTC（WebLogic-Tuxedo Connector）が推奨されます。詳しくはBEA WebLogic Server とのコネクティビティを参照してください。

Tuxedo CORBA対応

■ ATMI(Application-to-Transaction Monitor Interface)

ATMI とは、クライアントやサービスプログラムと TUXEDO トランザクションマネ ージャ間のアプリケーションインタフェースです。 ATMI は、X/Open によって OLTP アプリケーション・プログラミングの参照技術 として選択されています。

ATMIの使用（Oracle OTN）

Tuxedo ATMI

■ WebGUI

WebGUI は、Web / Java ベースのグラフィカル・ユーザ・インタフェース(GUI)で の Tuxedo 管理機能を提供します。ブラウザ上でのグラフィカルな表示により明確に、簡単にアプリケーション 管理を行う事ができます。

BEA Tuxedo Administration Console（Oracle OTN）

Tuxedo WebGUI

ページの先頭へ戻る

●スケーラビリティと信頼性

■ データ依存型ルーティング

あらかじめ指定したデータ・フィールド中の値に応じて、特定のサービスを選択して要求を処理させる事が出来ます。また、ルーティングルールを動的に変更することも可能です。

データ依存型ルーティング（Oracle OTN）

データ依存型ルーティング

■ ／Ｑ（高信頼性キュー）

/Q 機能は、メッセージを固定記憶領域の待ち行列（キュー）を使用した非同期型通信機能です。 /Q は、キューの名前を既存のサービスと同じ名前にすることにより、キューに登録されたメッセージを、そのサービスへ自動的に送信することもできます。また、メッセージ処理の開始時刻や有効期限、メッセージの優先度を設定することも可能です。 /Q を使用する事によって、トランザクション中のメッセージの保証、障害からのメッセージ回復を実現する事が出来ます。

メッセージ・キューイング通信（Oracle OTN）

Tuxedo　メッセージキューイング

■ リンクの多重化および障害検出・接続先自動切換え

リンクの多重化には、「/WS クライアント接続の多重化」、「MP 構成時の BRIDGE 接続の多重化」、「Domain 構成時の GATEWAY 接続の多重化」の３つがあります。多重化されたリンクをパラレルに使用することにより、通信速度を向上させることが可能になります。また、障害の発生したリンクを検出し、アクティブリンクへと自動的にフェールオーバーすることもできます。

リンクの多重化

■ SSSQとMSSQ

非常に簡単なコンフィギュレーションをするだけで、SSSQ（Single Server Single Queue）とMSSQ（Multiple Server Single Queue）モデルを用いたサーバの多重化を実現することができます。詳しくは、サーバ・プロセスを多重化するをご覧ください。

IPCメッセージ・キュー（Oracle OTN）

Tuxedo SSSQとMSSQ

■ QoSの確保（プライオリティ制御）

各サービスごとに優先度を設定することにより、同一メッセージキュー内にある要求の優先制御が可能になります。また、要求ごとに優先度を設定することも可能です。

メッセージの優先順位付け（Oracle OTN）

Tuxedo メッセージのプライオリティ制御

ページの先頭へ戻る

●拡張可能なインフラストラクチャ

■ Domain

システムが大規模になるにつれてシステムの一括管理／運用が難しくなってき ます。Tuxedo では、業務内容や地域ごとにアプリケーションを分割し、独立管 理することができます。これをドメインと呼びます。各ドメインでサポートしているサービスは、他ドメインのアプリケーションか らも要求することができ、サービスの分散を意識することはありません。 又、トランザクションにおいても他のドメインと相互動作することができます 。

Tuxedo　Domain

■ MIB（管理情報ベース）

MIB は、TUXEDO システムを構成するオブジェクト・クラスとその属性の定義を 提供します。Tuxedo システム管理者は、アプリケーション管理ツールもしくは ATMI を使ってこれらの値を取得できます。また、属性の値を変更することによって、 Tuxedo システムの構成を動的に変更することも可能です。

MIBを使用した操作の管理（Oracle OTN）

Tuxedo MIB（管理情報ベース）

■ マルチスレッド・マルチコンテキスト アプリケーション ※7.1J 以降

マルチコンテキストを使用すると、1 つのプロセスで複数ドメインへ接続することが可能になります。マルチコンテキストは、クライアントとサーバの両方で使用できますが、サーバでマルチコンテキストを使用するには、マルチスレッド・サーバにする必要があります。

Tuxedo システムでは、C言語で記述されたマルチスレッド・アプリケーションがサポートされています。 COBOL 言語のマルチスレッド・アプリケーションはサポートされていません。

マルチスレッドおよびマルチコンテキスト・アプリケーションのプログラミング（Oracle OTN）

Tuxedo マルチコンテキスト 
Tuxedo マルチスレッド

■ XML対応 ※7.1J以降

XML 文書を格納したデータバッファを受信すると、 Tuxedo ランタイムシステムが XML の構文解析を実行します。 XML 文書中の任意のフィールドの値を基準にして、データ依存型ルーティングが可能です。

XML型バッファ（Oracle OTN）

Tuxedo XML対応

■ 文字コードの自動変換 ※8.1J以降

マルチバイトエンコーディング対応のバッファタイプ “MBSTRING” を使用すると、異なるエンコーディングを使用しているプロセス間で自動的に文字コードを変換します。また、マルチバイト文字列操作用 API を使用すると、明示的に文字コードを変換することもできます。

マルチバイト文字符号化（Oracle OTN）
MBSTRING型バッファ（Oracle OTN）

Tuxedo マルチバイト文字符号化

■ XMLパーサ ※8.1J以降

Apache Xerces C++ バージョン 1.7 パーサが Tuxedo に組み込まれ、ユーザ・アプリケーションで XML データを読み書きできます。また、BEA が独自に開発した、XML スキーマや DTD のキャッシング機能を有効にすると、XML データの検証処理を高速に行うことができます。

XMLパーサの統合（Oracle OTN）

Tuxedo XMLパーサ

■ WebLogicとの認証情報の統合 ※8.1J以降

シングル・ポイント・セキュリティ管理オプションを使用すると、Tuxedo と WebLogic Server アプリケーションが WebLogic Server セキュリティ・データベースを共有できるようになります。これにより、ユーザの一元管理が可能となり、シングル・サインオン環境を構築することができるようになります。（この機能は、Tuxedo 8.1 アプリケーションと WebLogic Server 7.0 以降のアプリケーションを含むデプロイメントにのみ適用されます。）

シングル・ポイント・セキュリティ管理（Oracle OTN）

Tuxedo WebLogicとのセキュリティ管理

■ Tuxedo Jolt

Tuxedo Jolt とは、インターネット上での Tuxedo アプリケーションの開発、運用、管理 を容易に行うための機能です。 Java 対応の WWW ブラウザから、トランザクションセマンティクスを意識する事なく Tuxedo サービスを要求する事ができます。また Tuxedo Jolt を使用することで、Tuxedo とWebLogic Server とを容易に連携する事ができます。

Tuxedo Joltはオプション製品です。別途購入が必要になります。

Tuxedo Joltの詳細は、Tuxedo Joltの機能紹介をご覧ください
