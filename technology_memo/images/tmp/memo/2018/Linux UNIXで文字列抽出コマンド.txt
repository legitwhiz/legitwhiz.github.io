Linux/UNIXで文字列抽出コマンド

色々とシェルスクリプトで、文字列を抽出する場面が多いが
正直いちいち覚えてられないので(私の頭が悪いだけか...w)
自分用のあんちょことして残しておきます。(毎回、ググるのも面倒なので...w)

■ ====== 文字単位 =======
文字単位の抽出は、基本的に"cut -c"か"awk のsubstr"を使用する。

●左から◯文字
cut -c [開始文字(個数)]-[終了文字(個数)]

パラメータ展開を利用して抽出する場合
${変数:N}

●右から◯文字
rev | cut -c [開始文字(個数)]-[終了文字(個数)] | rev

パラメータ展開を利用して抽出する場合
${変数::N}

●右から◯文字を除外する
rev | cut -c [開始文字(個数)+1]- | rev

パラメータ展開を利用して抽出する場合
${変数::-N}

●文字A~文字Bまでを抽出する
awk '{print substr($0, index($0, "b"), index($0, "e") -1 )}'

●文字A~文字Bまでを除外する
awk '{sub("文字A.*.文字B", "");print $0;}'

awk '{print substr($0, 文字A, 文字B)}'

●指定した文字以降を抽出する
awk '{print substr($0, index($0, "文字"))}'

短縮形
awk '$0 = substr($0, 2)'

パラメータ展開を利用して抽出する場合
${変数##文字列} # 左から最長一致
${変数#文字列} # 左から最短一致

●指定した文字以降を除外する
awk '{sub("文字A.*", "");print $0;}'

パラメータ展開を利用して抽出する場合
${変数%%文字列} # 右から最長一致
${変数%文字列} # 右から最短一致

●先頭の N文字を取り除く
echo "$DATA1" | sed -e "s/^.{N}//"

●末尾の N文字を取り除く
echo "$DATA1" | sed -e "s/.{N}$//"

■ ====== 文字列単位 =======
文字列単位の抽出も基本的には"sed"を使用する。

●各行の最初に一致したパターンを削除
sed -e 's/<文字列>//'

●全てのパターンを削除
sed -e 's/<文字列>//g'

●数字以外を削除
sed -e 's/[^0-9]//g'

●行頭に文字を追加
sed -e 's/^/<文字列>/g'

●行末に文字列を追加
sed -e 's/$/<文字列>/g'

●連続する複数のスペースを1つにまとめる
sed -e 's/  */ /'
GNU sed (Linux 上の sed) では□+ で 1個以上の連続するスペースを表現することが可能である。
sed -e 's/ +/ /'

●変数を使用した文字列置換
sed -e "s/$VAR1/置換後パターン/"
sed -e "s/置換対象パターン/$VAR/"
sed -e "s/$VAR1/$VAR2/"
※sed コマンド内で変数を使用するには $ を打ち消さないようにダブルクォートを使用する。

●変数の文字列から部分的にを抽出(最初のn文字を除いて)
echo ${NAME:<n>

最初のn文字を除き、m文字分だけ取り出す場合
echo ${NAME:<n>:<m>}

最後のn文字を取り出す場合
echo ${NAME: -<n>}


●行を指定した置換
# 特定の 1行のみで置換を行う。
sed -e '行番号s/パターン1/パターン2/'

# 開始行～終了行の範囲でのみ置換を行う。
sed -e '開始行,終了行s/パターン1/パターン2/'


■ ====== フィールド単位(列の抽出) =======
フィールド単位の抽出も基本的には"cut"と"awk"を使用する。

●指定フィールド抽出
よく利用するテキストファイルの代表として、カンマ（,）でデータが区切られたCSVファイルがありますが、組込変数FSにカンマ（,）を代入することで、CSVファイルを扱うことができます。

$ echo "a,b,c" | awk -F',' '{print <フィールド>}'

省略形
$ echo "a b c" | awk '$0 = $2'
ただし、抜き出したいものが数字の0や空文字列である場合には偽になってしまうため、何も表示されません。

cutコマンドでも同様のことができます。
$ echo "0 1 2" | cut -d ' ' -f <フィールド>

$ echo "0,1,2" | cut -d , -f <フィールド>

●指定フィールド除外
$ echo "a b c" | awk '!(<フィールド> = "")'

また、フィールド数が少ない場合には、特定のフィールドを削除するよりも、消したいフィールド以外を表示したほうが、簡単で分かりやすいと思います。
$ echo "a b c" | awk '{print <フィールド>, <フィールド>}'

AWKにはフォーマットを指定して表示することができるprintf文もありますので、以下のようにしても同じ結果が得られます。
$ echo "a b c" | awk '{printf("%s %s\n", <フィールド>, <フィールド>)}'

●n行目のみフィールド抽出
awk '(NR == <行数>){ print <フィールド> }'

●n行目およびm行目のみフィールド抽出
awk '(NR == <行数> || NR == <行数>){ print <フィールド> }'

●n行目より大かつm行目以下のみフィールド抽出
awk '(NR > <行数> && NR <= <行数>){ print <フィールド> }'

■ ====== 行単位 =======
行単位の抽出は、基本的に"grep"、"awk"、"sed"を使用する。

●特定の文字列を含む行を抽出
grep <パターン>
awk '$0 ~ /b.*/'

●特定の文字列を含む行を削除
sed -e '/<パターン>/d'
grep -v <パターン>

●空行を削除
sed -e '/^$/d'

●n行目を削除
# 単一行の削除
sed -e '行番号d'

# 複数行の削除
sed -e '開始行,終了行d'

●最下行を削除
sed -e '$d' 

●特定の行のみを表示
# n行目を表示
sed -n '行番号p'

# n行目～m行目を表示
sed -n '開始行,終了行p'

●先頭が#もしくは空白行を除外
grep -v -e ^# -e ^$ 

●A行からB行までを切り出す
grep -A <行数> <パターン> textfile | grep -B <行数> <パターン>

●先頭行から n 行を表示
head -n 行数

●最下行から n 行を表示
tail -n 行数

●上から N 行目および下から M 行目までを表示
tail -n +N | head -n -(M-1)


■おまけ

"grep -o"は、正規表現にマッチした部分だけを抜き出す、
つまりAWKスクリプトと同じことがgrepコマンドでできてしまう。
って言うかいつのまにか、そんなオプションが追加されていたんですね。
-oオプションはVersion 2.5から新しく追加された機能です。
知っているコマンドだからといって、ただ単に使うのではなく
定期的にリリースノートを見るべきですね。

$ echo 'abcde' | grep -o 'b.*'
bcde

しかも、それだけでなく、文字列を1文字ずつ分離し、それぞれに改行を挿入する
「横→縦変換」も瞬時にこなしてくれるので便利です
（逆に、縦→横変換は引数なしのxargsコマンドで行えます）。

$ echo 'abcde' | grep -o '.'
a
b
c
d
e

